<!DOCTYPE HTML>
<html lang="zh-cn" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>架构工作台 - 架构治理模式</title>
        <!-- Custom HTML head -->
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../index.html">架构治理总览</a></li><li class="chapter-item expanded affix "><li class="part-title">架构治理基础</li><li class="chapter-item expanded "><a href="../basic/architecture-modeling.html"><strong aria-hidden="true">1.</strong> 架构建模</a></li><li class="chapter-item expanded "><a href="../basic/architecture-basic.html"><strong aria-hidden="true">2.</strong> 架构治理基础</a></li><li class="chapter-item expanded "><a href="../basic/architecture-patterns.html"><strong aria-hidden="true">3.</strong> 模式的模式</a></li><li class="chapter-item expanded "><a href="../basic/elemental-pattern.html"><strong aria-hidden="true">4.</strong> 元素化模式</a></li><li class="chapter-item expanded affix "><li class="part-title">数字化治理模式</li><li class="chapter-item expanded "><a href="../category/category-characteristic.html"><strong aria-hidden="true">5.</strong> 特征集合</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../category/category-characteristic-measure.html"><strong aria-hidden="true">5.1.</strong> 特征度量</a></li><li class="chapter-item expanded "><a href="../patterns/characteristics-repository.html"><strong aria-hidden="true">5.2.</strong> 架构特征仓库</a></li><li class="chapter-item expanded "><a href="../patterns/fitness-function.html"><strong aria-hidden="true">5.3.</strong> 架构适应度函数</a></li><li class="chapter-item expanded "><a href="../patterns/architecture-twin.html"><strong aria-hidden="true">5.4.</strong> 架构孪生</a></li></ol></li><li class="chapter-item expanded "><a href="../category/category-analysis.html"><strong aria-hidden="true">6.</strong> 分析</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../patterns/focus-driven.html"><strong aria-hidden="true">6.1.</strong> 关注点驱动</a></li><li class="chapter-item expanded "><a href="../patterns/analysis-lifecycle.html"><strong aria-hidden="true">6.2.</strong> 分解生命周期</a></li><li class="chapter-item expanded "><a href="../patterns/language-metamodel.html"><strong aria-hidden="true">6.3.</strong> 语言元模型</a></li><li class="chapter-item expanded "><a href="../patterns/dynamic-tracing.html"><strong aria-hidden="true">6.4.</strong> 动静态追踪</a></li></ol></li><li class="chapter-item expanded "><a href="../category/category-viz.html"><strong aria-hidden="true">7.</strong> 可视化</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../patterns/city-metaphor.html"><strong aria-hidden="true">7.1.</strong> 城市隐喻</a></li><li class="chapter-item expanded "><a href="../patterns/graph-network.html"><strong aria-hidden="true">7.2.</strong> 图网络</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../patterns/graph-dependency.html"><strong aria-hidden="true">7.2.1.</strong> 依赖图</a></li></ol></li><li class="chapter-item expanded "><a href="../patterns/interactive-analysis.html"><strong aria-hidden="true">7.3.</strong> 交互式分析</a></li></ol></li><li class="chapter-item expanded "><a href="../category/category-ordered.html"><strong aria-hidden="true">8.</strong> 有序</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../patterns/linter-limit-rule.html"><strong aria-hidden="true">8.1.</strong> 规则限定</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../patterns/gate-guard.html"><strong aria-hidden="true">8.1.1.</strong> 门禁</a></li></ol></li><li class="chapter-item expanded "><a href="../patterns/fact-based-modeling.html"><strong aria-hidden="true">8.2.</strong> 表征化建模过程</a></li><li class="chapter-item expanded "><a href="../patterns/lightweight-documentation.html"><strong aria-hidden="true">8.3.</strong> 轻量级文档</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../patterns/architecture-decision-record.html"><strong aria-hidden="true">8.3.1.</strong> 架构决策记录</a></li><li class="chapter-item expanded "><a href="../patterns/all-in-one-page.html"><strong aria-hidden="true">8.3.2.</strong> 架构一页纸</a></li></ol></li><li class="chapter-item expanded "><a href="../patterns/collaborative-workshop.html"><strong aria-hidden="true">8.4.</strong> 协同设计工作坊</a></li><li class="chapter-item expanded "><a href="../patterns/automated-monitoring.html"><strong aria-hidden="true">8.5.</strong> 自动化监测</a></li><li class="chapter-item expanded "><a href="../patterns/scaffolding.html"><strong aria-hidden="true">8.6.</strong> 内建模式的脚手架</a></li></ol></li><li class="chapter-item expanded "><a href="../category/category-language.html"><strong aria-hidden="true">9.</strong> 领域抽象</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../patterns/architecture-as-code.html"><strong aria-hidden="true">9.1.</strong> 架构即代码</a></li><li class="chapter-item expanded "><a href="../patterns/architecture-language.html"><strong aria-hidden="true">9.2.</strong> 架构语言</a></li><li class="chapter-item expanded "><a href="../patterns/architecture-workbench.html" class="active"><strong aria-hidden="true">9.3.</strong> 架构工作台</a></li></ol></li><li class="chapter-item expanded "><a href="../category/category-categorization.html"><strong aria-hidden="true">10.</strong> 范畴化</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../patterns/hierarchical-decomposition.html"><strong aria-hidden="true">10.1.</strong> 层次化分解</a></li><li class="chapter-item expanded "><a href="../patterns/layered-control.html"><strong aria-hidden="true">10.2.</strong> 层级层次控制</a></li><li class="chapter-item expanded "><a href="../patterns/access-control.html"><strong aria-hidden="true">10.3.</strong> 访问控制</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../patterns/limited-core-domain.html"><strong aria-hidden="true">10.3.1.</strong> 有限核心域</a></li></ol></li></ol></li><li class="chapter-item expanded "><li class="part-title">流程与能力治理模式</li><li class="chapter-item expanded "><div><strong aria-hidden="true">11.</strong> 流程</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../process/trend-lead-vision.html"><strong aria-hidden="true">11.1.</strong> X 技术描绘趋势</a></li><li class="chapter-item expanded "><a href="../process/incremental-guidance.html"><strong aria-hidden="true">11.2.</strong> 增量引导</a></li><li class="chapter-item expanded "><a href="../process/context-over-control.html"><strong aria-hidden="true">11.3.</strong> 上下文优于控制</a></li><li class="chapter-item expanded "><a href="../process/decision-framework.html"><strong aria-hidden="true">11.4.</strong> 决策制定框架</a></li><li class="chapter-item expanded "><a href="../process/responsibilities-matrix.html"><strong aria-hidden="true">11.5.</strong> 职责矩阵 (RACI)</a></li><li class="chapter-item expanded "><a href="../process/manage-dependency.html"><strong aria-hidden="true">11.6.</strong> 管理依赖</a></li><li class="chapter-item expanded "><a href="../process/lightweight-architecture-review.html"><strong aria-hidden="true">11.7.</strong> 轻量级架构检视</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">12.</strong> 能力</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../process/capability-assessment.html"><strong aria-hidden="true">12.1.</strong> 能力评估</a></li><li class="chapter-item expanded "><a href="../process/capability-mapping.html"><strong aria-hidden="true">12.2.</strong> 能力映射</a></li><li class="chapter-item expanded "><a href="../process/capability-heat-map.html"><strong aria-hidden="true">12.3.</strong> 能力热图</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">13.</strong> 知识管理</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../process/asset-deposition.html"><strong aria-hidden="true">13.1.</strong> 资产沉淀</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">组织与团队模式</li><li class="chapter-item expanded "><div><strong aria-hidden="true">14.</strong> 团队模式</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../team/team-topology.html"><strong aria-hidden="true">14.1.</strong> 团队拓扑</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">工具化模式</li><li class="chapter-item expanded "><div><strong aria-hidden="true">15.</strong> 工具化模式</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../tools/discovery-development.html"><strong aria-hidden="true">15.1.</strong> 探索-开发模式</a></li><li class="chapter-item expanded "><a href="../tools/self-service-data-analysis.html"><strong aria-hidden="true">15.2.</strong> 自服务数据分析</a></li><li class="chapter-item expanded "><a href="../tools/plugin-system.html"><strong aria-hidden="true">15.3.</strong> 插件化架构</a></li><li class="chapter-item expanded "><a href="../tools/dag-pipeline.html"><strong aria-hidden="true">15.4.</strong> DAG 管道模式</a></li><li class="chapter-item expanded "><a href="../tools/tool-shift-left.html"><strong aria-hidden="true">15.5.</strong> 工具前移</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">反模式</li><li class="chapter-item expanded "><div><strong aria-hidden="true">16.</strong> 流程</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../bad-patterns/pattern-escape.html"><strong aria-hidden="true">16.1.</strong> 模式逃逸</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><li class="part-title">参考资料</li><li class="chapter-item expanded "><a href="../reference/index.html"><strong aria-hidden="true">17.</strong> 参考资料</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">架构治理模式</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/archguard/book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/archguard/book/edit/master/src/patterns/architecture-workbench.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="架构工作台构建企业应用架构的数字孪生"><a class="header" href="#架构工作台构建企业应用架构的数字孪生">架构工作台：构建企业（应用）架构的数字孪生</a></h1>
<blockquote>
<p>架构工作台是一个环境，其设计初衷用于帮助人们设计架构、演进架构、观测架构，并有效地运用架构所需要的高质量工具，如交互式的架构开发和分析。</p>
</blockquote>
<h2 id="问题为什么需要架构工作台"><a class="header" href="#问题为什么需要架构工作台">问题：为什么需要架构工作台？</a></h2>
<p>在 ArchGuard 中，我们想治理的是架构的三种形态：<strong>设计态</strong>、<strong>开发态</strong>和<strong>运行态</strong>。对应于：</p>
<ul>
<li>
<p>设计新的企业（应用）架构。诸如于描述和设计系统的当前架构。</p>
</li>
<li>
<p>理解和管控系统的现状。诸如于通过可视化的手段展示系统的现状、以规则来管理系统。</p>
</li>
<li>
<p>观测系统 &lt;=&gt; 架构的运行。</p>
<p>同样，对于诸多中大型组织师的架构相关的部门来说，他们同样存在上述的这些问题。并且，我相信他们也面临着同我们构建 ArchGuard 时一样的困境：</p>
</li>
</ul>
<ol>
<li>架构是多维的。包含技术、数据、安全、运维与系统等</li>
<li>缺乏统一的架构<strong>语言</strong>。用于沟通的人类语言，诸如于什么是组件？</li>
<li>系统的架构千奇百怪。架构风格或模式差异，如微服务架构、插件化架构等。</li>
<li>缺乏业务上下文。作为一个外部架构师，帮助治理时缺乏一些上下文。</li>
<li>细节是魔鬼。架构的世界丰富多彩，没有办法一一展现出来，比如一个小小的接口，可能会反转我们对于理解的假设。</li>
<li>我们（ArchGuard 团队）目前的架构能力有限（~~这个不会写出来的~~）——  资深架构师太少。</li>
</ol>
<p>所以，在实现这样一个标准化的架构模式系统之前，不如尝试构建一个更灵活的形式：架构工作台。它可以帮助我们更好地探索系统，也更符合我们的初期体验。</p>
<h2 id="解决方案"><a class="header" href="#解决方案">解决方案</a></h2>
<p><img src="../images/archguard-workbench.png" alt="ArchGuard 架构工作台" /></p>
<h3 id="什么是架构工作台"><a class="header" href="#什么是架构工作台">什么是架构工作台</a></h3>
<p>对于工作台这一概念来说，作为一个活跃的 DSL 创造者，我比较熟悉的是 Martin Fowler 在《领域特定语言》中对于语言工作台的定义：</p>
<blockquote>
<p>语言工作台是一个环境，其设计初衷就是帮助人们构建新的 DSL，以及有效地运用这些 DSL 所需的高质量工具。</p>
</blockquote>
<p>也因此在定义上，我们参考了老马的定义，并借鉴了现代化的工作台理念，主要有：RStudio 的<strong>代码文档化</strong>、Jupyter 的<strong>交互性分析</strong>。所以，我们的定义是：</p>
<blockquote>
<p>架构工作台是一个环境，其设计初衷用于帮助人们设计架构、演进架构、观测架构，并有效地运用架构所需要的高质量工具，如交互式的架构开发和分析。</p>
</blockquote>
<p>代码文档化，用于帮助我们更好地管理<strong>架构代码</strong>，将它融入软件开发生命周期里，如架构文档、用户故事、持续集成等。而交互性分析，则是用于帮助我们有效减少定制的代码，进而演变为提供的是 API 接口，与其定制化的代码。</p>
<p>对于架构工作台来说，它应用包含了以下一些核心功能与特性：</p>
<ul>
<li>设计架构、演进架构与观测架构。</li>
<li>构建架构的数字孪生</li>
<li>说明性编程与显式设计</li>
</ul>
<p>在这些特性中，我们认为<strong>构建架构的数字孪生</strong>是这个工作台最应该被重视的部分，而基础块则是：设计架构、演进架构与观测架构。</p>
<h4 id="基础设计架构演进架构与观测架构"><a class="header" href="#基础设计架构演进架构与观测架构">基础：设计架构、演进架构与观测架构</a></h4>
<p>在治理架构时，我们通常会关注于如何设计，如何演进，以及观测架构在运行时的状态。</p>
<ul>
<li>**设计架构。**这样的功能其并不能理解，难点是，如何提供高效的设计机制？采用 UI 拖拉拽的方式，又或者是 DSL，都有各种的博弈。总体来说使用代码会更加友好。而为了直观的展示架构的设计，我们会通过架构图来表示，这也就是系统的核心。</li>
<li><strong>演进架构。<strong>其核心是</strong>构建架构治理模型</strong>和<strong>设计架构的适应度函数</strong>，以引导系统进行有序的变更。从实现的层面来说，就是从对实现出来的软件架构（即代码等）进行分析，设计度量指标，并提供高质量的工具，来引导架构回归到合理的状态。</li>
<li><strong>观测架构</strong>。即观察架构的应用的运行状态，主要依靠于各类的 APM（application performance management，应用性能监测）工具。在云原生时代，相关的工具也非常的流行，如 Skywalking 等。</li>
</ul>
<p>一个基础的架构工作台，应该考虑上述的三个要素。</p>
<h4 id="进阶构建架构的数字孪生"><a class="header" href="#进阶构建架构的数字孪生">进阶：构建架构的数字孪生</a></h4>
<p>理想的架构工作台，它应该提供一个可交互的架构的映射版本。它意味着：它是对系统或对象在其整个生命周期中的虚拟表示，我们可以根据实时数据进行更新，并使用<strong>模拟、机器学习和推理</strong>来帮助决策。</p>
<p>从概念上来说，它提供了一个非常美好的未来，难点就在于如何实现这样的系统？</p>
<p>我们正在设计 ArchGuard 的数字孪生版本，则围绕于这三种形态的架构形式（从实现的层面考虑的）：</p>
<ul>
<li>设计态。关注于<strong>边界</strong>、<strong>概念</strong>与<strong>交互</strong>。</li>
<li>开发态。关注于<strong>层级、依赖</strong>与<strong>模块</strong>。</li>
<li>运行态。关注于<strong>性能</strong>、<strong>链路层级</strong>与<strong>资源使用</strong>。</li>
</ul>
<p>这个版本相当于是设计态，在实现的时候，还会受到开发能力和数据上的制约。未来，我们是不是也应该代码及其架构孪生的双向绑定？</p>
<h4 id="核心说明性编程与显性设计"><a class="header" href="#核心说明性编程与显性设计">核心：说明性编程与显性设计</a></h4>
<p>我们所熟悉的各类架构相关的规范，它存在着诸多的问题，诸如于：<strong>规范不直观、规范没有自动化</strong>等。为了有效的演进架构，我们需要有效地结合规范、代码、设计，也就是说明性编程与显性设计，它们都是来自于 PL（编程语言）/ DSL（领域特定语言）中的概念。</p>
<ul>
<li><strong>说明性编程</strong>（illustrative programming）是用于加强执行结果的解释性，如在架构治理的场景下，通过<strong>生成架构图</strong>来理解 DSL 编写的结果。另外一类觉的方式，有诸如于 Excel 中的表格和图表等。详细可以查看文末 Martin Fowler 的相关文章。</li>
<li><strong>显式设计</strong>。<strong>显式</strong>是通过明确编写要完成的指示来完成所需更改的手动方法。显示设计则是指引我们如何构建好系统的描述语言，诸如于 ADL（架构描述语言）的 DSL。除了，使用贴进架构描述的语言，还有用于支撑 DSL 的工具支撑，如编辑器智能感知。</li>
</ul>
<p>这两个特性是围绕于<strong>架构即代码</strong>这一理念所改善的，诸如于 PlantUML、Graphviz 这一类图表即代码（Diagrams as code）也具备了这样的特质。</p>
<h4 id="其它特质"><a class="header" href="#其它特质">其它特质</a></h4>
<p>当然，为了让这个系统更好用，我们还需要其它的一系列特性：</p>
<ul>
<li>架构演进的模拟验证。在构建了架构的数字孪生之后，我们就可以</li>
<li>易于扩展的功能。即采用微内核架构，即插件化、微前端化等。</li>
</ul>
<p>依旧还有诸多东西可以探索，等待我们构建完第一个版本后，再展开讨论。</p>
<h2 id="示例archguard-架构工作台"><a class="header" href="#示例archguard-架构工作台">示例：ArchGuard 架构工作台</a></h2>
<h3 id="原型参考与设计可交互环境与文档体验"><a class="header" href="#原型参考与设计可交互环境与文档体验">原型参考与设计：可交互环境与文档体验</a></h3>
<p>什么是文档？什么是代码？两者没有一个明确的界限，文档是可执行的，代码也是可执行的。不过，从最终的形态上来说，它们都是知识。所以，重点依旧在于如何将这些知识显式化。所以从原型参考上，我们关注于：可交互环境与文档体验设计。</p>
<h3 id="可交互环境jupyter--zeppelin---nteract"><a class="header" href="#可交互环境jupyter--zeppelin---nteract">可交互环境：Jupyter &amp; Zeppelin &amp;  Nteract</a></h3>
<p>作为交互性编程的业内代表，Jupyter 成为了我们研究的第一个对象。不过，从实现上，我们并没有从它本身的源码上汲取到太多的内容（ “代码”）。反而是，围绕于它的生态及竞争对手上，我们看到了一些更有意思的亮点，诸如于 Kotlin Jupyter、Zeppelin、Nteract 等。</p>
<ul>
<li>Nteract 提供了一系列的组件、SDK 来，用来构建交互式应用，诸如于消息通信等等。然而 Nteract ，在设计的时候主要是在 Electron 环境下使用，所以有一些库是无法使用的，如 ZeroMQ —— 设计时是只针对于 Node 环境的。</li>
<li>Zeppelin 构建了一个更简单的执行环境（Interpreter），与 Jupyter 的 Kernel API 相比，它可以提供一些更有意思的实现层面的抽象。</li>
<li>Kotlin Jupyter 则成了我们现在实现的一个基石。因为它还处于早期试验阶段，我们在构建的过程中，遇到过一系列的依赖包丢失的情况。</li>
</ul>
<p>回过头来看，我们应该需要再回去看看 Jupyter 的抽象接口，或许能再提供更多的思路。</p>
<h3 id="文档阅读体验与文档工程体验"><a class="header" href="#文档阅读体验与文档工程体验">文档阅读体验与文档工程体验</a></h3>
<p>对于文档体验来说，我一直主张应该关注于两个部分：</p>
<ul>
<li>文档阅读体验。即向读者提供的文档体验。</li>
<li>文档工程体验。即向工程提供的文档编写体验。（这一部分往往容易被忽视）</li>
</ul>
<p>对于文档体验来说，除了用于说明性编程的各类架构图，还需要提供各类的定义化能力。其参考来源来源主要是：我们日常的开发中的编程语言的文档编写，详细可以参考《<a href="https://www.phodal.com/blog/api-ducumentation-design-dsl-base/">API 库的文档体系支持：主流编程语言的文档设计</a>》与《<a href="https://www.phodal.com/blog/documentation-enginnering-experience-design/">文档工程体验设计：重塑开发者体验</a>》。</p>
<p>而诸如于 Mermaid、Graphviz 这一类的图即代码（diagram as code），它们在两者提供了一个很好的平衡（只针对于程序员）。</p>
<h3 id="技术评估dslrepl-与编辑器"><a class="header" href="#技术评估dslrepl-与编辑器">技术评估：DSL、REPL 与编辑器</a></h3>
<p>再回到实现上来，在进行架构工作台的技术评估时，我们关注于架构师编写的 DSL（领域特定语言）语法、REPL（read–eval–print loop） 运行环境以及用于交互的编辑器。其核心关注点是：如何构建更好的<a href="https://github.com/phodal/dx">开发者体验</a>，一个老生常谈的、难话题。</p>
<h4 id="dsl-语法antlr-vs-kotlin-dsl"><a class="header" href="#dsl-语法antlr-vs-kotlin-dsl">DSL 语法：Antlr vs Kotlin DSL</a></h4>
<p>在 ArchGuard 中，主要使用的是 Antlr 框架来进行不同语言的语法解析（即 Chapi）。因此，使用 Antlr 来设计一个新的 DSL 及其编译器前端，对于我们而言，并不存在技术上的挑战。甚至于，在以往的经历中，我们也有大型 IDEA 插件架构设计与开发的经历。</p>
<p>然而对于 DSL 来说，我们要考虑的核心因素是：</p>
<ul>
<li><strong>语法的学习成本。</strong></li>
<li><strong>语法的体验设计。</strong></li>
<li><strong>语法的编辑器/IDE 支持。</strong></li>
</ul>
<p>如果语法只是是个语言的 API，那它能大大降低学习成本。虽然 Kotlin 有点陌生，但是 Groovy + Gradle 都很熟吧。于是乎，我们采用的方式是基于 Kotlin 语言自带的 <a href="https://kotlinlang.org/docs/type-safe-builders.html">Type-safe builders﻿</a> 来构建构建 DSL。官方给的一个参考示例是 Ktor 的路由示例：</p>
<pre><code class="language-javascript">routing {
    get(&quot;/hello&quot;) {
        call.respondText(&quot;Hello&quot;)
    }
}
</code></pre>
<p>除了已经有丰富的 IDE、编辑器的支持之外。在构建<strong>架构适应度函数</strong>时，也可以使用语言库提供的数学功能，以便于定制各类的计算规则。</p>
<h4 id="架构-replkotlin-scripting-vs-kotlin-jupyter"><a class="header" href="#架构-replkotlin-scripting-vs-kotlin-jupyter">架构 REPL：Kotlin Scripting vs Kotlin Jupyter</a></h4>
<p>而对于构建一个交互式架构 REPL 来说，我们需要需要考虑的一个核心点是：<strong>构建执行上下文（EvalContext）</strong>。即后面运行的代码是依赖于前面代码提供的上下文的，如变量等：<code>val x = 2 * 3</code>，后续就可以使用 <code>x</code> 。</p>
<p>对于我们来说，有两个选择：</p>
<ul>
<li>
<p>Kotlin 语言自带的试验性功能：Kotlin Scripting 提供了一种无需事先编译或打包成可执行文件即可将 Kotlin 代码作为脚本执行的技术。因为，对于我们来说，只需要构建我们的 DSL 包，就可以直接执行。</p>
</li>
<li>
<p>Kotlin Jupyter 的实现也是基于 Kotlin Scripting 提供了一系列的 API 封装。</p>
</li>
</ul>
<p>在 REPL 上，起初我们纠结于自己实现，还是基于 Kotlin Jupyter，毕竟 Jupyter 包含了一系列的不需要的代码。后来，发现代码好复杂，虽然都是 MIT 协议，但是我们也不想维护一个不稳定功能的下游版本。</p>
<p>因此，在最后，我们基于 Kotlin Jupyter 的 API 构建了 ArchGuard 的架构 REPL。</p>
<h4 id="探索编辑器prosemirror-vs-others"><a class="header" href="#探索编辑器prosemirror-vs-others">探索编辑器：ProseMirror vs Others</a></h4>
<p>对于编辑器来说，考虑的核心点是：<strong>组件扩展性</strong>。即，可以按需添加用于展示图表的组件，又或者是其它的结果展示相关组件。</p>
<p>在设计上 Jupyter、Zeppelin 采用的是块（Cell）式编辑器，即文档是按<strong>块</strong>的形式切开来的。稍有区别的是 Jupyter 基于 CodeMirror，则 Zeppelin  是基于 Monaco Editor。这种基于块式的编辑功能，有点割裂，提供的交互体验对于纯键盘操作不友好。</p>
<p>于是乎，为了探索更好的文档交互方式，我们陆陆续续参考了一系列的编辑器：CodeMirror、Draft.js、Lexical、ProseMirror 等。ProseMirror 是 CodeMirror 作者的另外一个作品，融合了 Markdown 与传统的 WYSIWYG 编辑器。也就是说：即可以写 Markdown 也可以用富文本的方式（PS：在编写此文时，我使用的 Quake 的底层也是 ProseMirror）。即，它可以同时满足两类人的需求，<strong>使用 Markdown 和不使用 Markdown</strong>，他们能都从编辑器上获得自己的鼠标（markdown）和键盘（富文本）。</p>
<p>探索完之后，我们发现基于 ProseMirror 的 <a href="https://github.com/outline/rich-markdown-editor">rich-markdown-editor</a> 能提供所需要的功能。只需要编写一些<strong>类</strong> ProseMirror 插件，不需要编写大量的 markdown 相关的处理功能。</p>
<h3 id="落地构建数据通讯与结果呈现"><a class="header" href="#落地构建数据通讯与结果呈现">落地：构建数据通讯与结果呈现</a></h3>
<p>为了验证整个 PoC （Proof of Concept，概念证明）是可行的，接下来就是让数据作为胶水把一切串联起来，构建这样一个完整的端到端示例：</p>
<ol>
<li>前端 → REPL。在前端编写 DSL，执行运行，交数据发送给 REPL。</li>
<li>REPL → 前端。REPL 解析数据，将后续的 Action，返回给前端。</li>
<li>前端 → 后端。前端根据 Action，决定是显示架构图，还是发请求给后端。</li>
<li>后端 → 前端。后端根据前端的请求，执行对应的命令，再将结果返回给前端。</li>
<li>前端。前端再根据后端的数据处理。</li>
</ol>
<p>所以，其实核心的部分只有一个：<strong>模型的设计</strong>，诸如于：Message 和 Action。</p>
<h4 id="数据传输与处理message-模型"><a class="header" href="#数据传输与处理message-模型">数据传输与处理：Message 模型</a></h4>
<p>在 REPL 服务中，通过 WebSocket 接收到前端的数据之后，就需要将其转换为对应的数据，并返回给前端。如下是在 PoC 中，我们所定义的 Message ：</p>
<pre><code class="language-javascript">data class Message(
    var id: Int = -1,
    var resultValue: String,
    var className: String = &quot;&quot;,
    var msgType: MessageType = MessageType.NONE,
    var content: MessageContent? = null,
    var action: ReactiveAction? = null,
)
</code></pre>
<p>在执行前端传入的代码后，会根据不同的执行结果，返回一些后续的 Action 信息（代码中的 <code>ReactiveAction</code>），以及对应的数据（在 <code>action</code> 中）。</p>
<h4 id="repl构建执行环境"><a class="header" href="#repl构建执行环境">REPL：构建执行环境</a></h4>
<p>对于 REPL 来说，我们还需要做的事情有：</p>
<ol>
<li>构建 REPL 环境。如添加 ArchGuard DSL 的 jar 包，以及对应的 Kotlin Scripting、Kotlin Jupyter 的 Jar。</li>
<li>添加 <code>% archguard</code> Magic。添加一个自定义的 <code>LibraryResolver</code> 。</li>
</ol>
<p>虽然对于 REPL 不熟悉，但是幸好在有 Kotlin Jupyter 的源码作为参考，这个过程并不算太痛苦。虽然过程，也是异常的痛苦：没有可用的文档、环境只为 Jupyter 设计、只能看测试用例。但是，至少还是可以看<strong>测试用例</strong> —— 测试是个好东西。</p>
<p>在开发环境下，会加载 Java 运行环境的 classpath （详细见：<strong>KotlinReplWrapper</strong>）：</p>
<pre><code class="language-javascript">val property = System.getProperty(&quot;java.class.path&quot;)
var embeddedClasspath: MutableList&lt;File&gt; = property.split(File.pathSeparator).map(::File).toMutableList()
</code></pre>
<p>在运行环境下，则会只引用所需要的 jar 包。两个环境的不一致，也需要在后续探索一下如何进行优化。</p>
<h4 id="编辑器"><a class="header" href="#编辑器">编辑器：</a></h4>
<p>在我们落地的过程中，编辑器的实现被分为两部分，一个是编写 ProseMirror 插件，另外一个则是完善 Monaco Editor 的感知。</p>
<p><strong>ProseMirror</strong> <strong>插件编写</strong></p>
<p>针对于代码块，编写了 <code>LivingCodeFenceExtension</code> 插件替换了 rich-markdown-editor 中的代码块语法功能，并指向了 Monaco Editor 组件：</p>
<pre><code class="language-javascript">&lt;CellEditor
  language={language}
  code={value}
  removeSelf={this.deleteSelf(props)}
  codeChange={this.handleCodeChange}
  context={this.options.context}
  languageChange={this.handleLanguageChange}
/&gt;
</code></pre>
<p>再围绕于两个编辑器，构建了一系列的交互，如：语言变更、删除代码块、执行代码等。</p>
<p><strong>围绕 Monaco Editor</strong> <strong>构建 DSL 开发者体验</strong></p>
<p>Monaco Editor 的完善，主要会围绕于：添加代码高亮、自动填充与智能感知。现在，只完成了基本的功能，还有很多功能需要后续进行探索。</p>
<h4 id="结果展示与图形"><a class="header" href="#结果展示与图形">结果展示与图形</a></h4>
<p>对于结果来说，其核心的部分在 <code>ResultDispatcher</code> 上，顾名思义，根据不同的结果来展示不同的展示结果，诸如于：</p>
<pre><code class="language-javascript">switch (result.action.actionType) {
  case ActionType.CREATE_REPO:
    return &lt;BackendActionView data={data} actionType={BackendActionType.CreateRepos} /&gt;;
  case ActionType.CREATE_SCAN:
    return &lt;BackendActionView data={data} actionType={BackendActionType.CreateScan} /&gt;;
  case ActionType.GRAPH:
    return &lt;GraphRender result={result} context={context}/&gt;;
}
</code></pre>
<p>而为了更好的呈现<strong>技术相关的图形细节</strong>，我们在 ArchGuard 中引入了第<strong>五个图形库</strong>（由于几个图形库的存在，构建变成了一件痛苦的事，大概是最大的技术债了）：Mermaid。先前的 Echart.js 可以为我们提供低成本的图形编写，D3.js 则是提供了更灵活的定制能力。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../patterns/architecture-language.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="../category/category-categorization.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../patterns/architecture-language.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="../category/category-categorization.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script>
            window.playground_copyable = true;
        </script>
        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>
        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
