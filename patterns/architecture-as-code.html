<!DOCTYPE HTML>
<html lang="zh-cn" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>架构即代码 - 架构治理模式</title>
        <!-- Custom HTML head -->
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../index.html">架构治理总览</a></li><li class="chapter-item expanded affix "><li class="part-title">架构治理基础</li><li class="chapter-item expanded "><a href="../basic/architecture-modeling.html"><strong aria-hidden="true">1.</strong> 架构建模</a></li><li class="chapter-item expanded "><a href="../basic/architecture-basic.html"><strong aria-hidden="true">2.</strong> 架构治理基础</a></li><li class="chapter-item expanded "><a href="../basic/architecture-patterns.html"><strong aria-hidden="true">3.</strong> 模式的模式</a></li><li class="chapter-item expanded "><a href="../basic/elemental-pattern.html"><strong aria-hidden="true">4.</strong> 元素化模式</a></li><li class="chapter-item expanded affix "><li class="part-title">数字化治理模式</li><li class="chapter-item expanded "><a href="../category/category-characteristic.html"><strong aria-hidden="true">5.</strong> 特征集合</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../category/category-characteristic-measure.html"><strong aria-hidden="true">5.1.</strong> 特征度量</a></li><li class="chapter-item expanded "><a href="../patterns/characteristics-repository.html"><strong aria-hidden="true">5.2.</strong> 架构特征仓库</a></li><li class="chapter-item expanded "><a href="../patterns/fitness-function.html"><strong aria-hidden="true">5.3.</strong> 架构适应度函数</a></li><li class="chapter-item expanded "><a href="../patterns/architecture-twin.html"><strong aria-hidden="true">5.4.</strong> 架构孪生</a></li></ol></li><li class="chapter-item expanded "><a href="../category/category-analysis.html"><strong aria-hidden="true">6.</strong> 分析</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../patterns/focus-driven.html"><strong aria-hidden="true">6.1.</strong> 关注点驱动</a></li><li class="chapter-item expanded "><a href="../patterns/analysis-lifecycle.html"><strong aria-hidden="true">6.2.</strong> 分解生命周期</a></li><li class="chapter-item expanded "><a href="../patterns/language-metamodel.html"><strong aria-hidden="true">6.3.</strong> 语言元模型</a></li><li class="chapter-item expanded "><a href="../patterns/dynamic-tracing.html"><strong aria-hidden="true">6.4.</strong> 动静态追踪</a></li></ol></li><li class="chapter-item expanded "><a href="../category/category-viz.html"><strong aria-hidden="true">7.</strong> 可视化</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../patterns/city-metaphor.html"><strong aria-hidden="true">7.1.</strong> 城市隐喻</a></li><li class="chapter-item expanded "><a href="../patterns/graph-network.html"><strong aria-hidden="true">7.2.</strong> 图网络</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../patterns/graph-dependency.html"><strong aria-hidden="true">7.2.1.</strong> 依赖图</a></li></ol></li><li class="chapter-item expanded "><a href="../patterns/interactive-analysis.html"><strong aria-hidden="true">7.3.</strong> 交互式分析</a></li></ol></li><li class="chapter-item expanded "><a href="../category/category-ordered.html"><strong aria-hidden="true">8.</strong> 有序</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../patterns/linter-limit-rule.html"><strong aria-hidden="true">8.1.</strong> 规则限定</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../patterns/gate-guard.html"><strong aria-hidden="true">8.1.1.</strong> 门禁</a></li></ol></li><li class="chapter-item expanded "><a href="../patterns/fact-based-modeling.html"><strong aria-hidden="true">8.2.</strong> 表征化建模过程</a></li><li class="chapter-item expanded "><a href="../patterns/lightweight-documentation.html"><strong aria-hidden="true">8.3.</strong> 轻量级文档</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../patterns/architecture-decision-record.html"><strong aria-hidden="true">8.3.1.</strong> 架构决策记录</a></li><li class="chapter-item expanded "><a href="../patterns/all-in-one-page.html"><strong aria-hidden="true">8.3.2.</strong> 架构一页纸</a></li></ol></li><li class="chapter-item expanded "><a href="../patterns/collaborative-workshop.html"><strong aria-hidden="true">8.4.</strong> 协同设计工作坊</a></li><li class="chapter-item expanded "><a href="../patterns/automated-monitoring.html"><strong aria-hidden="true">8.5.</strong> 自动化监测</a></li><li class="chapter-item expanded "><a href="../patterns/scaffolding.html"><strong aria-hidden="true">8.6.</strong> 内建模式的脚手架</a></li></ol></li><li class="chapter-item expanded "><a href="../category/category-language.html"><strong aria-hidden="true">9.</strong> 领域抽象</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../patterns/architecture-as-code.html" class="active"><strong aria-hidden="true">9.1.</strong> 架构即代码</a></li><li class="chapter-item expanded "><a href="../patterns/architecture-language.html"><strong aria-hidden="true">9.2.</strong> 架构语言</a></li><li class="chapter-item expanded "><a href="../patterns/architecture-workbench.html"><strong aria-hidden="true">9.3.</strong> 架构工作台</a></li></ol></li><li class="chapter-item expanded "><a href="../category/category-categorization.html"><strong aria-hidden="true">10.</strong> 范畴化</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../patterns/hierarchical-decomposition.html"><strong aria-hidden="true">10.1.</strong> 层次化分解</a></li><li class="chapter-item expanded "><a href="../patterns/layered-control.html"><strong aria-hidden="true">10.2.</strong> 层级层次控制</a></li><li class="chapter-item expanded "><a href="../patterns/access-control.html"><strong aria-hidden="true">10.3.</strong> 访问控制</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../patterns/limited-core-domain.html"><strong aria-hidden="true">10.3.1.</strong> 有限核心域</a></li></ol></li></ol></li><li class="chapter-item expanded "><li class="part-title">流程与能力治理模式</li><li class="chapter-item expanded "><div><strong aria-hidden="true">11.</strong> 流程</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../process/trend-lead-vision.html"><strong aria-hidden="true">11.1.</strong> X 技术描绘趋势</a></li><li class="chapter-item expanded "><a href="../process/incremental-guidance.html"><strong aria-hidden="true">11.2.</strong> 增量引导</a></li><li class="chapter-item expanded "><a href="../process/context-over-control.html"><strong aria-hidden="true">11.3.</strong> 上下文优于控制</a></li><li class="chapter-item expanded "><a href="../process/decision-framework.html"><strong aria-hidden="true">11.4.</strong> 决策制定框架</a></li><li class="chapter-item expanded "><a href="../process/responsibilities-matrix.html"><strong aria-hidden="true">11.5.</strong> 职责矩阵 (RACI)</a></li><li class="chapter-item expanded "><a href="../process/manage-dependency.html"><strong aria-hidden="true">11.6.</strong> 管理依赖</a></li><li class="chapter-item expanded "><a href="../process/lightweight-architecture-review.html"><strong aria-hidden="true">11.7.</strong> 轻量级架构检视</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">12.</strong> 能力</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../process/capability-assessment.html"><strong aria-hidden="true">12.1.</strong> 能力评估</a></li><li class="chapter-item expanded "><a href="../process/capability-mapping.html"><strong aria-hidden="true">12.2.</strong> 能力映射</a></li><li class="chapter-item expanded "><a href="../process/capability-heat-map.html"><strong aria-hidden="true">12.3.</strong> 能力热图</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">13.</strong> 知识管理</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../process/asset-deposition.html"><strong aria-hidden="true">13.1.</strong> 资产沉淀</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">组织与团队模式</li><li class="chapter-item expanded "><div><strong aria-hidden="true">14.</strong> 团队模式</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../team/team-topology.html"><strong aria-hidden="true">14.1.</strong> 团队拓扑</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">工具化模式</li><li class="chapter-item expanded "><div><strong aria-hidden="true">15.</strong> 工具化模式</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../tools/discovery-development.html"><strong aria-hidden="true">15.1.</strong> 探索-开发模式</a></li><li class="chapter-item expanded "><a href="../tools/self-service-data-analysis.html"><strong aria-hidden="true">15.2.</strong> 自服务数据分析</a></li><li class="chapter-item expanded "><a href="../tools/plugin-system.html"><strong aria-hidden="true">15.3.</strong> 插件化架构</a></li><li class="chapter-item expanded "><a href="../tools/dag-pipeline.html"><strong aria-hidden="true">15.4.</strong> DAG 管道模式</a></li><li class="chapter-item expanded "><a href="../tools/tool-shift-left.html"><strong aria-hidden="true">15.5.</strong> 工具前移</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">反模式</li><li class="chapter-item expanded "><div><strong aria-hidden="true">16.</strong> 流程</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../bad-patterns/pattern-escape.html"><strong aria-hidden="true">16.1.</strong> 模式逃逸</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><li class="part-title">参考资料</li><li class="chapter-item expanded "><a href="../reference/index.html"><strong aria-hidden="true">17.</strong> 参考资料</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">架构治理模式</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/archguard/book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/archguard/book/edit/master/src/patterns/architecture-as-code.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="架构即代码编码下一代企业应用架构体系"><a class="header" href="#架构即代码编码下一代企业应用架构体系">架构即代码：编码下一代企业（应用）架构体系</a></h1>
<blockquote>
<p>架构即代码，是一种架构设计和治理的思想，它围绕于架构的一系列模式，将架构元素、特征进行组合与呈现，并将架构决策与设计原则等紧密的与系统相结合。</p>
</blockquote>
<p>如我的上一篇文章《<a href="https://www.phodal.com/blog/architecture-model/">为“架构”再建个模：如何用代码描述软件架构？</a>》中所说，要准确描述软件的架构是一件颇具难度的事情。仅就实现的层面来说，也已经很难通过一个标准模型来让所有人达成一致，“哦，这就是架构”。也因此，在无法定义架构的情况下，也很难无法给出一个让所有人信服的架构治理模型。毕竟：<strong>模型只有合适的，永远没有对的</strong>。</p>
<p>但是呢，我们（ArchGuard Team）依旧会在 ArchGuard 构建出一个架构模型，以及架构治理模型，作为推荐的 “<strong>最佳实践</strong>”。除此，我们还应该提供一种<strong>自定义</strong>企业应用架构的可能性，这就是<strong>架构即代码</strong>。面向初级架构师来说，他们只需要按照 ArchGuard 的最佳实践来实施即可；面向中高级架师，他们可以基于 ArchGuard 提供的插件化能力 + DSL 构建自己的架构体系。</p>
<p>所以，如你在其它系统中所看到的那样，要提供这样的能力，需要一定的编码、配置等。所以，我们就需要构建一个<strong>架构即代码</strong>的系统。那么，问题来了，即代码又是什么鬼。</p>
<h2 id="架构即代码是什么"><a class="header" href="#架构即代码是什么">架构即代码是什么？</a></h2>
<p>在先前的一系列的代码化（<a href="https://ascode.ink/">https://ascode.ink/</a>）文章中，描述了如何将软件开发完全代码化，包含了将文档、需求、设计、代码、构建、部署、运营等变成代码化。设计和实现一个领域特定语言并不难，如《<a href="https://www.phodal.com/blog/step-by-step-domain-specific-language-design/">领域特定语言设计技巧</a>》一文中所描述的过程，在这个上下文之下就是：</p>
<ol>
<li>定义呈现模式。寻找适合于呈现架构的方式，如 UML 图、依赖图、时序图等。</li>
<li>提炼领域特定名词。一系列的架构相关元素，如架构风格：微内核等、架构分层：MVC 等。</li>
<li>设计关联关系与语法。如何以自然的方式来关联这些架构元素，如关键词、解析占位符等。</li>
<li>实现语法解析。除了实现之后，另外一种还要考虑的是：如何提供更灵活的扩展能力？</li>
<li>演进语言的设计。版本迭代</li>
</ol>
<p>也因此，我们将架构即代码定义为：</p>
<blockquote>
<p>架构即代码，是一种架构设计和治理的思想，它围绕于架构的一系列模式，将架构元素、特征进行组合与呈现，并将架构决策与设计原则等紧密的与系统相结合。</p>
</blockquote>
<p>接下来的问题就是，如何将这个理念有机的与系统结合在一起？并友好地提供这样的 API 接口（DSL）？</p>
<p>于是放到当前 ArchGuard 的 PoC，架构即代码的呈现方式是 “ArchDoc”，一种基于 Markdown 的交互式代码分析和治理方式。即所有的 “代码” 都通过 markdown 来管理，优点有一大堆：</p>
<ul>
<li>使用内嵌 DSL （用语法块管理）表述架构</li>
<li>可以记录系统的架构文档，如架构决策、业务架构等</li>
<li>拥有广泛的解析库，能提供更灵活的定制灵感（Ctrl + C, Ctrl + V）。</li>
<li>自定义 Render</li>
<li>广泛的编辑工具支持</li>
</ul>
<p>唯一的缺点就是实现这样一个工具并不简单。</p>
<h2 id="架构即代码的特点"><a class="header" href="#架构即代码的特点">架构即代码的特点</a></h2>
<p>不过，我们已经实现了一个简单的 PoC（概念证明）版本，在这个版本里，它的特点是：</p>
<ul>
<li>显式地描述与呈现架构。</li>
<li>架构文档即是规则</li>
<li>设计、文档与实现一致</li>
</ul>
<p>当然了，还有各种的可扩展能力（这是一个再普通不过的特点了）。</p>
<h3 id="显式地描述与呈现架构"><a class="header" href="#显式地描述与呈现架构">显式地描述与呈现架构</a></h3>
<p>回到日常里，我们经常听架构师说，“我们的服务采用的是标准的 DDD 的分层架构”。但是，这个分层是不是诸如于 “Interface 层依赖于 application、domain、infrastructure 层” 等一系列的依赖关系？开发人员是否知道这些规则？这些都是问题。所以，一个架构即代码的系统，它应该能显式地呈现出系统中的那些隐性知识。</p>
<p>诸如于，我们应该将分层中的依赖关系，显式地声明写出来：</p>
<pre><code class="language-javascript">layered {
    prefixId(&quot;org.archguard&quot;)
    component(&quot;interface&quot;) dependentOn component(&quot;application&quot;)
    组件(&quot;interface&quot;) 依赖于 组件(&quot;domain&quot;)
    component(&quot;interface&quot;) dependentOn component(&quot;infrastructure&quot;)

    组件(&quot;application&quot;) 依赖于 组件(&quot;domain&quot;)
    组件(&quot;application&quot;) 依赖于 组件(&quot;infrastructure&quot;)

    组件(&quot;domain&quot;) 依赖于 组件(&quot;infrastructure&quot;)
}
</code></pre>
<p>PS：请忽视上面 Kotlin 代码中的中文元素，它只是用来说明使用中文描述的可能性。毕竟，开心的话，也可以使用文言文。</p>
<p>结合 ArchGuard 中的 DSL 与可视化工具（这里采用的是 Mermaid.js），就能呈现我们所设计的分层架构：</p>
<p><img src="/processor/blog/images?file_name=2022-05-14T12:01:03.999Z.svg" alt="" /></p>
<p>再再结合一下设计的分层 Linter 工具（正在实现中）：</p>
<pre><code class="language-javascript">linter('Backend').layer()
</code></pre>
<p>一旦分层中的依赖关系错了，就可以在持续集成中阻断这些代码的提交 —— 类似于 ArchUnit 这样的机制。稍有区别的是，你不需要将测试和代码放在代码库中，而是可以统一的去管理它们。</p>
<p>而对于其它一系列的更复杂的规则来说，我们可以自定义它们，并将他们与文档结合在一起。</p>
<h3 id="架构文档即是规则"><a class="header" href="#架构文档即是规则">架构文档即是规则</a></h3>
<p>在这种模式之下，我们还可以将文档与代码相结合 —— 前提是：我们已经编写了一系列的规则。如我们在 ArchGuard 中，针对于不同的场景编写了一系列的规则：</p>
<ul>
<li>SQL，如不允许 <code>select *</code> 等</li>
<li>Test Code，用于检测代码中的坏味道</li>
<li>Web API ，分析 API 的设计是否 RESTful</li>
<li>Layer （待实现），分析代码中的分层实现</li>
<li>Arch （待实现），类似于 <a href="https://github.com/TNG/ArchUnit">ArchUnit</a> 或者 <a href="https://github.com/modernizing/guarding">Guarding</a> 制定更细的依赖规则</li>
<li>Change（待实现），编写自定义的变更影响范围规则，如某个类不应该被其它的变更影响到</li>
</ul>
<p>有了基本架构文档规范之后，我们可以规则化它们，并结合到一起。如下是一个结合 Checklist 和规则的列表示例：</p>
<pre><code>- [x] 不应该存在被忽略（Ignore、Disabled）的测试用例 (#no-ignore-test)
- [ ] 允许存在重复的 assertion (#redundant-assertion) 
</code></pre>
<p><code>#no-ignore-test</code> 对应于正在实现的 ArchGuard 中的规则，而 GFM 的 Checklist 中，如果 check 了，则可以表示为开启规则；如果没有 check，则为不开启。前面的文字部分，则是对应的规则描述，与传统的 linter 相比较，略显灵活。</p>
<p>而不论是编写文档还是阅读文档的人，他们可以很轻松地构建起对应的上下文。</p>
<h3 id="设计文档与代码一致"><a class="header" href="#设计文档与代码一致">设计、文档与代码一致</a></h3>
<p>有了设计和文档之后，就需要结合到已有的代码中，让三者保持一致和准确。在我们的场景之下，就是 ArchGuard 已有的 API，它包含了：</p>
<ol>
<li>创建对于代码仓库的分析</li>
<li>分析代码的语法和构建工具、变更历史等</li>
<li>分析代码是否满足规则等</li>
</ol>
<p>如下是 ArchGuard 中对于 repo 设计的 DSL（基于 Kotlin），用于创建代码仓库的分析：</p>
<pre><code class="language-javascript">repos { 
    repo(name = &quot;Backend&quot;, language = &quot;Kotlin&quot;, scmUrl = &quot;https://github.com/archguard/archguard&quot;)
    repo(name = &quot;Frontend&quot;, language = &quot;TypeScript&quot;, scmUrl = &quot;https://github.com/archguard/archguard-frontend&quot;)
    repo(name = &quot;Scanner&quot;, language = &quot;Kotlin&quot;, scmUrl = &quot;https://github.com/archguard/scanner&quot;)
}
</code></pre>
<p>只有三者保持了一致，我们才能确保架构的设计与实现是一致的。</p>
<h2 id="架构即代码是个什么系统"><a class="header" href="#架构即代码是个什么系统">架构即代码是个什么系统？</a></h2>
<p>从实现的层面来说，一个架构即代码系统是一个支持编排的数据系统。原因在于，我们并不想关心数据处理的过程，但是想获取数据的结果，从结果中获取洞见。正如，我们所见到的一个个大数据系统，构建了一个个的可视化能力，以祈祷从中得到洞见。</p>
<p>不过，和祈祷稍有不同的是，我们是带着 N% 可能性的猜想，所以叫做探索。</p>
<h3 id="一种探索式的架构治理"><a class="header" href="#一种探索式的架构治理">一种探索式的架构治理</a></h3>
<p>传统的软件开发模型是：<strong>编辑-编译-运行</strong>（edit-compile-run），这种开发模型的前提是，我们拥有足够的业务洞见。对于一个带着丰富领域知识的业务系统来说，构建这样一个系统并不是一件困难。但是，当我们缺乏足够的领域专家，我们应该如何往下走呢？复杂问题，你只能探索 (Probe)  -&gt; 感知 (Sense) -&gt; 响应 (Respond)。</p>
<p>而既然我们本身和很多新生代的架构师一样，也需要探索，也需要分析，然后才是得到结论。那么，我们不妨再尝试切换一下模式。如同，我们构建 ArchGuard 的软件开发模型，也是<strong>执行-探索</strong>（execute-explore），先从分析一下系统（发布一个分析功能），再配合已有的模式，最后得到 “结论” 或者规则（再发布一个 linter 功能）。</p>
<p>在数据领域，这种方式相当的流行，过去人们用 IPython，现在都改用 Jupyter；另外一个类型则是类似于 RMarkdown 提供的报表式的思路。</p>
<ul>
<li>IPython。 is a command shell for interactive computing in multiple programming languages.</li>
<li>Jupyter Notebook. is a web-based interactive computing platform.</li>
<li>R Markdown。Turn your analyses into high quality documents, reports, presentations and dashboards with <em>R Markdown</em>.</li>
<li>D3.js 社区的 Observable。用于 Explore, analyze, and explain data. As a team.</li>
</ul>
<p>从模式上来说，ArchGuard 更偏向于 RStudio 的模式，只是从社区的资源上来说，Jupyter 相关的实现比较多。</p>
<h3 id="一个经常-oom-的-大数据系统"><a class="header" href="#一个经常-oom-的-大数据系统">一个经常 OOM 的 “大数据系统”</a></h3>
<p>在我们（ArchGuard core team）的 “数次讨论” 中，最终认为 ArchGuard 是一个大数据分析，而不是简单的数据分析。原因是系统中存在大量的 bug 和大数据相关的（狗头）：</p>
<ul>
<li>存在一定数量的 Out of Memory。</li>
<li>大数据量情况下的可视化优化。</li>
</ul>
<p>也就是所谓的 ”bug 驱动的架构设计“。</p>
<p>除此，之后另外一个颇有意思的点是，对于更大型的系统来说，它存在大量的新的提交，又或者是新的分支。我们即需要考虑：<strong>应对持续提交的代码，构建增量分析的功能</strong>。</p>
<p>当我们尝试使用大数据的思路，如 MapReduce、Streaming Analysis 相关的模式来解决相关的问题时，发现它是可以 work 的不错的 —— 毕竟都是数据分析。</p>
<h2 id="在-archguard-是如何实现的"><a class="header" href="#在-archguard-是如何实现的">在 ArchGuard 是如何实现的？</a></h2>
<p>ArchGuard 围绕于 DSL + Kotlin REPL + 数据可视化，构建了一个可交互的架构分析与治理平台。因为还在实现中，所以叫下一代。</p>
<h3 id="1-提炼架构元素"><a class="header" href="#1-提炼架构元素">1. 提炼架构元素</a></h3>
<p>上文中的（<a href="https://ascode.ink/">https://ascode.ink/</a>）系列中，也包含了两个架构相关的工具，一个是代码生成 DSL：<a href="https://github.com/inherd/forming">Forming</a>、另外一个则是架构守护 DSL：<a href="https://github.com/modernizing/guarding">Guarding</a>。两个 DSL 所做的事情是，围绕<strong>特定的规则</strong>将<strong>架构元素</strong>组合到一起，这里的架构元素。</p>
<p>如果没有做过，这一个过程看上去是挺麻烦的，实现上有一些颇为简单的东西可以参考（复制）：</p>
<ul>
<li>架构描述语言论文（ADL）。ADL 已经是一个很成熟的领域了，在设计模式火的那个年代，架构模式（《面向模式的软件架构》）也特别的火。</li>
<li>架构相关书籍的目录。一本好的架构书，只需要看目录就能有个索引，所以也就有了基本的架构元素。</li>
<li>架构的模式语言。模式语言所呈现的是模式之间的关系</li>
<li>……</li>
</ul>
<p>仅仅是复制那多没意思，要是能自己做做抽象，也是一种非常好玩的事情。</p>
<h3 id="2-构建插件化与规则分析"><a class="header" href="#2-构建插件化与规则分析">2. 构建插件化与规则分析</a></h3>
<p>如上所述，在 ArchGuard 中，我们尝试以一系列的规则，构建系统的规则，而这些规则是以插件化的形式暴露的。</p>
<p>这就意味着，这样一个系统应该是支持自定义的插件化能力，它即可以让你：</p>
<ol>
<li>接入一个新的语言</li>
<li>编写新的规则</li>
<li>构建新数据的 pipeline</li>
</ol>
<p>在 ArchGuard 中还需要改进的是，提供一种元数据的能力。</p>
<h3 id="3-抽象-dsl-作为胶水"><a class="header" href="#3-抽象-dsl-作为胶水">3. 抽象 DSL 作为胶水</a></h3>
<p>从实现层面来说，为了支撑粘合的能力，我们目前计划设计了三种能力的 DSL：<strong>后端架构查询 DSL、架构 DSL、特征 DSL</strong>。</p>
<p><strong>后端架构查询 DSL</strong></p>
<p>类似于 LINQ （Language Integrated Query，语言集成查询）封装 CRUD 接口，以提供编译时类型检查或智能感知支持，在 Kotlin 中有诸如于：<a href="https://github.com/kotlin-orm/ktorm">KtOrm</a> 的形式。如：</p>
<pre><code class="language-javascript">database
    .from(Employees)
    .select(Employees.name)
    .where { (Employees.departmentId eq 1) and (Employees.name like &quot;%vince%&quot;) }
    .forEach { row -&gt; 
        println(row[Employees.name])
    }
</code></pre>
<p>像一个编程语言编写，可以提供更友好的语法性支持。</p>
<p><strong>架构 DSL</strong></p>
<p>即架构描述语言（Architecture Description Language），以提供一种有效的方式来描述软件架构。</p>
<p><strong>特征 DSL：分析、扫描与 Linter</strong></p>
<p>即封装 ArchGuard Scanner、Analyser、Linter 等，用于构建系统所需要的基础性架构特征。</p>
<h3 id="4-构建可交互的环境"><a class="header" href="#4-构建可交互的环境">4. 构建可交互的环境</a></h3>
<p>两年前，在与众多的 Thoughtworker 一起构建 <a href="https://github.com/phodal/ledge">Ledge</a> 的时候，我们就一直在强调<a href="https://www.phodal.com/blog/document-as-code/">文档代码化</a>，并提供可交互的文档环境。在 Ledge 里，你可以使用 Markdown 来绘制各类的图表，只需要借助声明图表类型，示例见：<a href="https://devops.phodal.com/helper">https://devops.phodal.com/helper</a> 。</p>
<p>从模式上来说，ArchGuard 更像是一个  RStudio + Jupyter 的结合版，即提供了大量自定义图形 + 组件能力的 REPL。</p>
<p>在 REPL 上，由于我们计划使用 Kotlin 构建 DSL，所以需要寻找的是 Kotlin 的 REPL。Kotlin 官方创建的 <a href="https://github.com/Kotlin/kotlin-jupyter">kotlin-jupyter</a> 便成为了一个很好的参考，可惜还没有用得上。与此同时，Kotlin 在设计初期就有了 Kotlin Scripting 的场景，所以其实 <code>kotlin-scripting-compiler-embeddable</code> 就能满足需求。于是，在 PoC 里，我们参考了 Apache Zeppelin 引入了 Kotlin REPL，并创建了一个 WebSocket 作为服务。</p>
<p>在可视化上，稍微复杂一些，需要构建一个 Markdown 解析器、Block 编辑器等。我们暂时采用了 Mermaid.js 作为可视化的图形库之一，另外的还有 D3.js、Echarts 也是其中之一。剩下的问题，便是如何通过 DSL 来整合它们？构建前后端的数据模型是一个临时的方案？</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../category/category-language.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="../patterns/architecture-language.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../category/category-language.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="../patterns/architecture-language.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script>
            window.playground_copyable = true;
        </script>
        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>
        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
