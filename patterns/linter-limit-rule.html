<!DOCTYPE HTML>
<html lang="zh-cn" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>规则限定 - 架构治理模式</title>
        <!-- Custom HTML head -->
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../index.html">架构治理总览</a></li><li class="chapter-item expanded affix "><li class="part-title">架构治理基础</li><li class="chapter-item expanded "><a href="../basic/architecture-modeling.html"><strong aria-hidden="true">1.</strong> 架构建模</a></li><li class="chapter-item expanded "><a href="../basic/architecture-basic.html"><strong aria-hidden="true">2.</strong> 架构治理基础</a></li><li class="chapter-item expanded "><a href="../basic/architecture-patterns.html"><strong aria-hidden="true">3.</strong> 模式的模式</a></li><li class="chapter-item expanded "><a href="../basic/elemental-pattern.html"><strong aria-hidden="true">4.</strong> 元素化模式</a></li><li class="chapter-item expanded affix "><li class="part-title">数字化治理模式</li><li class="chapter-item expanded "><a href="../category/category-characteristic.html"><strong aria-hidden="true">5.</strong> 特征集合</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../category/category-characteristic-measure.html"><strong aria-hidden="true">5.1.</strong> 特征度量</a></li><li class="chapter-item expanded "><a href="../patterns/characteristics-repository.html"><strong aria-hidden="true">5.2.</strong> 架构特征仓库</a></li><li class="chapter-item expanded "><a href="../patterns/fitness-function.html"><strong aria-hidden="true">5.3.</strong> 架构适应度函数</a></li><li class="chapter-item expanded "><a href="../patterns/architecture-twin.html"><strong aria-hidden="true">5.4.</strong> 架构孪生</a></li></ol></li><li class="chapter-item expanded "><a href="../category/category-analysis.html"><strong aria-hidden="true">6.</strong> 分析</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../patterns/focus-driven.html"><strong aria-hidden="true">6.1.</strong> 关注点驱动</a></li><li class="chapter-item expanded "><a href="../patterns/analysis-lifecycle.html"><strong aria-hidden="true">6.2.</strong> 分解生命周期</a></li><li class="chapter-item expanded "><a href="../patterns/language-metamodel.html"><strong aria-hidden="true">6.3.</strong> 语言元模型</a></li><li class="chapter-item expanded "><a href="../patterns/dynamic-tracing.html"><strong aria-hidden="true">6.4.</strong> 动静态追踪</a></li></ol></li><li class="chapter-item expanded "><a href="../category/category-viz.html"><strong aria-hidden="true">7.</strong> 可视化</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../patterns/city-metaphor.html"><strong aria-hidden="true">7.1.</strong> 城市隐喻</a></li><li class="chapter-item expanded "><a href="../patterns/graph-network.html"><strong aria-hidden="true">7.2.</strong> 图网络</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../patterns/graph-dependency.html"><strong aria-hidden="true">7.2.1.</strong> 依赖图</a></li></ol></li><li class="chapter-item expanded "><a href="../patterns/interactive-analysis.html"><strong aria-hidden="true">7.3.</strong> 交互式分析</a></li></ol></li><li class="chapter-item expanded "><a href="../category/category-ordered.html"><strong aria-hidden="true">8.</strong> 有序</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../patterns/linter-limit-rule.html" class="active"><strong aria-hidden="true">8.1.</strong> 规则限定</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../patterns/gate-guard.html"><strong aria-hidden="true">8.1.1.</strong> 门禁</a></li></ol></li><li class="chapter-item expanded "><a href="../patterns/fact-based-modeling.html"><strong aria-hidden="true">8.2.</strong> 表征化建模过程</a></li><li class="chapter-item expanded "><a href="../patterns/lightweight-documentation.html"><strong aria-hidden="true">8.3.</strong> 轻量级文档</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../patterns/architecture-decision-record.html"><strong aria-hidden="true">8.3.1.</strong> 架构决策记录</a></li><li class="chapter-item expanded "><a href="../patterns/all-in-one-page.html"><strong aria-hidden="true">8.3.2.</strong> 架构一页纸</a></li></ol></li><li class="chapter-item expanded "><a href="../patterns/collaborative-workshop.html"><strong aria-hidden="true">8.4.</strong> 协同设计工作坊</a></li><li class="chapter-item expanded "><a href="../patterns/automated-monitoring.html"><strong aria-hidden="true">8.5.</strong> 自动化监测</a></li><li class="chapter-item expanded "><a href="../patterns/scaffolding.html"><strong aria-hidden="true">8.6.</strong> 内建模式的脚手架</a></li></ol></li><li class="chapter-item expanded "><a href="../category/category-language.html"><strong aria-hidden="true">9.</strong> 领域抽象</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../patterns/architecture-as-code.html"><strong aria-hidden="true">9.1.</strong> 架构即代码</a></li><li class="chapter-item expanded "><a href="../patterns/architecture-language.html"><strong aria-hidden="true">9.2.</strong> 架构语言</a></li><li class="chapter-item expanded "><a href="../patterns/architecture-workbench.html"><strong aria-hidden="true">9.3.</strong> 架构工作台</a></li></ol></li><li class="chapter-item expanded "><a href="../category/category-categorization.html"><strong aria-hidden="true">10.</strong> 范畴化</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../patterns/hierarchical-decomposition.html"><strong aria-hidden="true">10.1.</strong> 层次化分解</a></li><li class="chapter-item expanded "><a href="../patterns/layered-control.html"><strong aria-hidden="true">10.2.</strong> 层级层次控制</a></li><li class="chapter-item expanded "><a href="../patterns/access-control.html"><strong aria-hidden="true">10.3.</strong> 访问控制</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../patterns/limited-core-domain.html"><strong aria-hidden="true">10.3.1.</strong> 有限核心域</a></li></ol></li></ol></li><li class="chapter-item expanded "><li class="part-title">流程与能力治理模式</li><li class="chapter-item expanded "><div><strong aria-hidden="true">11.</strong> 流程</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../process/trend-lead-vision.html"><strong aria-hidden="true">11.1.</strong> X 技术描绘趋势</a></li><li class="chapter-item expanded "><a href="../process/incremental-guidance.html"><strong aria-hidden="true">11.2.</strong> 增量引导</a></li><li class="chapter-item expanded "><a href="../process/context-over-control.html"><strong aria-hidden="true">11.3.</strong> 上下文优于控制</a></li><li class="chapter-item expanded "><a href="../process/decision-framework.html"><strong aria-hidden="true">11.4.</strong> 决策制定框架</a></li><li class="chapter-item expanded "><a href="../process/responsibilities-matrix.html"><strong aria-hidden="true">11.5.</strong> 职责矩阵 (RACI)</a></li><li class="chapter-item expanded "><a href="../process/manage-dependency.html"><strong aria-hidden="true">11.6.</strong> 管理依赖</a></li><li class="chapter-item expanded "><a href="../process/lightweight-architecture-review.html"><strong aria-hidden="true">11.7.</strong> 轻量级架构检视</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">12.</strong> 能力</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../process/capability-assessment.html"><strong aria-hidden="true">12.1.</strong> 能力评估</a></li><li class="chapter-item expanded "><a href="../process/capability-mapping.html"><strong aria-hidden="true">12.2.</strong> 能力映射</a></li><li class="chapter-item expanded "><a href="../process/capability-heat-map.html"><strong aria-hidden="true">12.3.</strong> 能力热图</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">13.</strong> 知识管理</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../process/asset-deposition.html"><strong aria-hidden="true">13.1.</strong> 资产沉淀</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">组织与团队模式</li><li class="chapter-item expanded "><div><strong aria-hidden="true">14.</strong> 团队模式</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../team/team-topology.html"><strong aria-hidden="true">14.1.</strong> 团队拓扑</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">工具化模式</li><li class="chapter-item expanded "><div><strong aria-hidden="true">15.</strong> 工具化模式</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../tools/discovery-development.html"><strong aria-hidden="true">15.1.</strong> 探索-开发模式</a></li><li class="chapter-item expanded "><a href="../tools/self-service-data-analysis.html"><strong aria-hidden="true">15.2.</strong> 自服务数据分析</a></li><li class="chapter-item expanded "><a href="../tools/plugin-system.html"><strong aria-hidden="true">15.3.</strong> 插件化架构</a></li><li class="chapter-item expanded "><a href="../tools/dag-pipeline.html"><strong aria-hidden="true">15.4.</strong> DAG 管道模式</a></li><li class="chapter-item expanded "><a href="../tools/tool-shift-left.html"><strong aria-hidden="true">15.5.</strong> 工具前移</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">反模式</li><li class="chapter-item expanded "><div><strong aria-hidden="true">16.</strong> 流程</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../bad-patterns/pattern-escape.html"><strong aria-hidden="true">16.1.</strong> 模式逃逸</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><li class="part-title">参考资料</li><li class="chapter-item expanded "><a href="../reference/index.html"><strong aria-hidden="true">17.</strong> 参考资料</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">架构治理模式</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/archguard/book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/archguard/book/edit/master/src/patterns/linter-limit-rule.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="限定规则"><a class="header" href="#限定规则">限定规则</a></h1>
<div class="table-wrapper"><table><thead><tr><th>时机</th><th>创建态</th><th>开发态</th><th>测试态</th><th>集成态</th><th>运行态</th></tr></thead><tbody>
<tr><td>关注点</td><td>代码规范内建、规范执行机制、分层规范等</td><td>代码规范</td><td>代码规范、分层架构、API 规范等</td><td>质量门禁</td><td>服务依赖</td></tr>
<tr><td>工具示例</td><td>应用脚手架</td><td>CheckStyle 的 Intellij IDEA插件</td><td>ArchUnit</td><td>Sonarqube</td><td>Skywalking</td></tr>
</tbody></table>
</div>
<h2 id="问题开发规范治理"><a class="header" href="#问题开发规范治理">问题：开发规范治理</a></h2>
<p>对于软件研发来说，效能的提升是一个非常宏大的史诗级话题，在这个话题里，规范的建立是一个非常有效的方案 ——
当且仅当，我们建立了配套的相关执行机制和工具。在确保了拥有统一规范的情况下，A 团队的开发人员，可以快速地到 B
团队开发，而不需要一些额外的讨论。简单来说，规范就是一种用于规模化提升效能的<strong>模式</strong>。</p>
<p>多年前，对于软件开发的规范，我们主要依赖于口头约定 + code review，这依赖于团队拥有比较好的技术能力。应对于规模化时，这样的模式是无法实施的。特别是
<strong>开发团队质量不齐</strong>的情况下，依附于个人的自觉，已经难于控制团队的质量。特别是，我们会因为越来越多的 quick
fix，导致一次又一次性破坏系统的规范。</p>
<p>人们开发了一系列的 Lint、Checkstyle、守护工具，以确保我们设计的规范能被实施下去。诸如于：</p>
<ul>
<li>针对于前端，我们有 ESLint、Prettier</li>
<li>针对于后端，我们也有一系列的工具，如：PMD/CheckStyle。还有国内流行的阿里、华为 Java 规范。</li>
<li>针对于 Java 架构，我们有：ArchUnit</li>
<li>针对于 API，我们有：API Linter、Spectral</li>
<li>针对于数据库，我们有：SQLFluff</li>
</ul>
<p>于是，在单体系统里，上述的一系列情况得到了有效的改善，但是我们来到了微服务时代、微前端时代等，整体又发现了一系列的变化。为了应对于这种变化，我们还需要一些额外的工具，以确保这些规范化的工具能被安装和使用。</p>
<h3 id="分布式的规范工具化"><a class="header" href="#分布式的规范工具化">分布式的规范工具化</a></h3>
<p>对于这些规范来说，它们的工具化思路类似于，我们在《<a href="https://github.com/modernizing/modernization">代码分析与自动化重构</a>》
所说的：源码分析 → 构建模型 → 识别模式 → 得到结果。为了支撑到分布式场景，一些潜在的方案便是：</p>
<ul>
<li>工具化代码块。使用额外的代码模块（如 Git Submodule、软件包等）来执行规范的自动化，诸如于 npm 包、jar 包的形式。</li>
<li>工具检查器。检查是否安装了对应的工具，是否执行了对应的步骤。（并不推荐）</li>
<li>构建新的工具。如 Guarding 这种模式。</li>
<li>设计成熟度指标。用于指导和改善系统的架构设计。</li>
</ul>
<p>去年，在设计 Guarding 这个多语言的架构守护工具时，其与 ArchUnit 相比的场景是：多语言、多代码库。与 ArchUnit 相比，Guarding
推荐的这种守护方式是：</p>
<ul>
<li>以 CLI 的方式运行。无需额外的编码工作，不担心系统被破坏。</li>
<li>配置在持续集成中。</li>
<li>多系统多语言守护。</li>
</ul>
<p>当然了，它更多的是在测试态、开发态来解决问题。理想情况下，应该包含 IDE 插件，在开发时能提醒开发人员，系统架构有哪些问题。</p>
<h3 id="指标模型架构适应度函数"><a class="header" href="#指标模型架构适应度函数">指标模型：架构适应度函数</a></h3>
<p>虽然，我们可以构建一个基于“分布式”场景的规范，但是从某种意义上来说，这些规范是一种约束。对于开发人员来说，我们需要一种更好的指导指标，而不是我们破坏了哪些规则。所以，我们应该考虑架构适应度函数的方式，从多个不同的维度，来帮助开发人员：</p>
<ol>
<li>理解系统的当前状态</li>
<li>理解指标对于系统的意义</li>
<li>指导系统更好的演进</li>
<li>知悉什么是好的模式和设计</li>
</ol>
<p>也因此，从这个层面来考虑，单体系统里的 Sonarqube 就是一个非常好的工具。</p>
<h2 id="解决方案"><a class="header" href="#解决方案">解决方案</a></h2>
<h3 id="时机"><a class="header" href="#时机">时机</a></h3>
<p>从模式上，我们通常会在如下的一些时机里，来检查软件是否符合规范。（按顺序排序）</p>
<ul>
<li>创建态。即将规范内嵌到每个应用的创建模板中。典型的形式是应用脚手架 等。</li>
<li>开发态。即结合开发过程中的工具（如 IDE、Git、CLI），将规范内置到开发流程中。典型的有 Git Hooks、IDE 插件等。</li>
<li>测试态。即结合自动化测试、契约测试等，在运行测试的时机，检查已有的系统是否遵循相关的规范。</li>
<li>集成态。即对于规范的检查配置在持续集成中，有时会作为一种强制的软件质量门禁。典型的有 SonarQube 等。</li>
<li>运行态。即结合软件运行的信息（如 APM、日志、分布式链路系统等），对系统进行系统进行分析。典型的有 NewRelic、Skywalking 等。</li>
</ul>
<p>从执行顺序来时机来说，越往前便意料着越能及早的发现错误，成本也越低。当然了，每种不同的时期，都应该有各自的重点。</p>
<div class="table-wrapper"><table><thead><tr><th>时机</th><th>关注点</th><th>工具示例</th></tr></thead><tbody>
<tr><td>创建态</td><td>代码规范内建、规范执行机制、分层规范等</td><td>应用脚手架</td></tr>
<tr><td>开发态</td><td>代码规范</td><td>CheckStyle 的 Intellij IDEA插件</td></tr>
<tr><td>测试态</td><td>代码规范、分层架构、API 规范等</td><td>ArchUnit</td></tr>
<tr><td>集成态</td><td>质量门禁</td><td>Sonarqube</td></tr>
<tr><td>运行态</td><td>服务依赖</td><td>Skywalking</td></tr>
</tbody></table>
</div>
<p>当然了，还有一些是跨越了多个不同的时机，诸如于契约测试，它是在开发时期定义的，但是可能会在测试态、集成态才验证的。然而，在过程中，很大一部分的内容都是在代码中，由开发人员控制的。作为一个开发者，也是一个
hacker，我们会习惯性的：</p>
<ol>
<li>跳过不需要的自动化检查。</li>
<li>路过不需要的测试。它可能跑起来很慢</li>
<li>删除或者禁用一些不需要的规范代码或者配置。</li>
</ol>
<p>这样一来，哪怕我们做了再好的规范设计，代码不，没有 code review 的保障，那么系统就会被进一步地腐化。</p>
<h3 id="实现示例"><a class="header" href="#实现示例">实现示例</a></h3>
<p>对于我们来说，构建一个类似的工具，需要考虑的一些因素有：</p>
<ul>
<li>插件化。开发人员可以根据已有的守护规则，开发一些新的架构守护规则，如针对于 API 的，针对于数据库调用链路的。</li>
<li>可测试性。如果采用的是完全 DSL 或者 半 DSL，那么如何让后续的</li>
<li>语言无关。如何不绑定于语言的语法树，而实现对于多种语言的支持。</li>
</ul>
<p>出于这个目的，只好拿起现有的代码进行一番分析，主要有四个工具，适用于 Kotlin 语言的 KtLint、适用于 OpenAPI 的
Spectral、适用于多数据库的 SQLFluff，以及被诸如 MyBatis 采用的表达式语言 Ognl。</p>
<h4 id="kotlin-代码的治理ktlint"><a class="header" href="#kotlin-代码的治理ktlint">Kotlin 代码的治理：KtLint</a></h4>
<p>KtLint 与一般的 Lint 工具稍有区别的是，它自带了一个自动格式化的功能。KtLint 整体的逻辑还是比较简单的，基于单个文件进行 AST
生成，随后针对于 AST 进行规则匹配。Ktlint 围绕于 Rule、Rulesets、RulesetsProvider 构建了规则的层级关系，同时用 Vistor （即
VisitorProvider）模式围绕 AST 进行分析，如下是 KtLint 的抽象 Rule：</p>
<pre><code class="language-kotlin">/**
 * This method is going to be executed for each node in AST (in DFS fashion).
 *
 * @param node AST node
 * @param autoCorrect indicates whether rule should attempt auto-correction
 * @param emit a way for rule to notify about a violation (lint error)
 */
abstract fun visit(
    node: ASTNode,
    autoCorrect: Boolean,
    emit: (offset: Int, errorMessage: String, canBeAutoCorrected: Boolean) -&gt; Unit
)
</code></pre>
<p>如注释中所说的，三个参数代表了各自的用途。这里的 ASTNode 是来源于 Kotlin 的 AST 树（ <code>kotlin-compiler-embeddable</code>
包）。模式上也是获取配置，然后运行检测规则：</p>
<pre><code class="language-kotlin">val ruleSets = ruleSetProviders.map { it.value.get() }
val visitorProvider = VisitorProvider(ruleSets, debug)
</code></pre>
<p>其中对应的 visit：</p>
<pre><code class="language-kotlin">visitorProvider
  .visitor(
      params.ruleSets,
      preparedCode.rootNode,
      concurrent = false
  ).invoke { node, rule, fqRuleId -&gt;    }
</code></pre>
<p>在 VistorProvider 中会过滤对应的规则：</p>
<pre><code class="language-kotlin">val enabledRuleReferences =
    ruleReferences
        .filter { ruleReference -&gt; isNotDisabled(rootNode, ruleReference.toQualifiedRuleId()) }
val enabledQualifiedRuleIds = enabledRuleReferences.map { it.toQualifiedRuleId() }
val enabledRules = ruleSets
    .flatMap { ruleSet -&gt;
        ruleSet
            .rules
            .filter { rule -&gt; toQualifiedRuleId(ruleSet.id, rule.id) in enabledQualifiedRuleIds }
            .filter { rule -&gt; isNotDisabled(rootNode, toQualifiedRuleId(ruleSet.id, rule.id)) }
            .map { rule -&gt; &quot;${ruleSet.id}:${rule.id}&quot; to rule }
    }.toMap()
....
</code></pre>
<p>然后，再去并行或者串行地运行 Rule 里的 visit。</p>
<p>而对于规则的方式是通过 ServicesLoader 进行的插件化方式：</p>
<pre><code class="language-kotlin">private fun getRuleSetProvidersByUrl(
    url: URL?,
    debug: Boolean
): Pair&lt;URL?, List&lt;RuleSetProvider&gt;&gt; {
    if (url != null &amp;&amp; debug) {
        logger.debug { &quot;JAR ruleset provided with path \&quot;${url.path}\&quot;&quot; }
    }
    val ruleSetProviders = ServiceLoader.load(
        RuleSetProvider::class.java,
        URLClassLoader(listOfNotNull(url).toTypedArray())
    ).toList()
    return url to ruleSetProviders.toList()
}
</code></pre>
<p>如果粒度更大的情况下，采用 Java 9 的模块是不是会更加方便？</p>
<h4 id="基于-api-数据的-spectral"><a class="header" href="#基于-api-数据的-spectral">基于 API 数据的 Spectral</a></h4>
<p>与 Ktlint 不同的是 Spectral 是一个针对于 JSON/YAML Lint 的工具，特别是针对于 OpenAPI 文档（就是 swagger 的 yaml/json 文件）。与
Ktlint 相比，Spectral 最有趣的地方是，它提供了一个 JSON Path（类似于 XPath）的功能，可以针对于对象中的特定部分，进采用特定的规则。如下是
Spectral 的示例：</p>
<pre><code class="language-javascript">'oas3-valid-schema-example'
:
{
    description: 'Examples must be valid against their defined schema.',
        message
:
    '{{error}}',
        severity
:
    0,
        formats
:
    [oas3],
        recommended
:
    true,
        type
:
    'validation',
        given
:
    [
        &quot;$.components.schemas..[?(@property !== 'properties' &amp;&amp; @ &amp;&amp; (@ &amp;&amp; @.example !== void 0 || @.default !== void 0) &amp;&amp; (@.enum || @.type || @.format || @.$ref || @.properties || @.items))]&quot;,
        &quot;$..content..[?(@property !== 'properties' &amp;&amp; @ &amp;&amp; (@ &amp;&amp; @.example !== void 0 || @.default !== void 0) &amp;&amp; (@.enum || @.type || @.format || @.$ref || @.properties || @.items))]&quot;,
        &quot;$..headers..[?(@property !== 'properties' &amp;&amp; @ &amp;&amp; (@ &amp;&amp; @.example !== void 0 || @.default !== void 0) &amp;&amp; (@.enum || @.type || @.format || @.$ref || @.properties || @.items))]&quot;,
        &quot;$..parameters..[?(@property !== 'properties' &amp;&amp; @ &amp;&amp; (@ &amp;&amp; @.example !== void 0 || @.default !== void 0) &amp;&amp; (@.enum || @.type || @.format || @.$ref || @.properties || @.items))]&quot;,
    ],
        then
:
    {
        function: oasExample

    ,
        functionOptions: {
            schemaField: '$',
                oasVersion
        :
            3,
                type
        :
            'schema',
        }
    ,
    }
,
}
</code></pre>
<p>上面对象中的 <code>given</code> 即是针对于对象中的相关属性作为条件，执行后面的 <code>then</code>
函数，详细可以见官方的文档：《<a href="https://meta.stoplight.io/docs/spectral/ZG9jOjI1MTg5-custom-rulesets#then">Custom Rulesets</a>
》。顺带一提：Spectral 采用的是 <a href="https://github.com/P0lip/nimma">nimma</a> 作为 JSON Path 表达式。</p>
<h4 id="spectral-的模型"><a class="header" href="#spectral-的模型">Spectral 的模型</a></h4>
<p>与 Ktlint 相比，由于 Spectral 是与 OpenAPI/Async API
进行了相关的绑定，加上特定的规则表达式，所以其数据模型稍微复杂一些。其数据模型包含了：描述，消息级别，given - then，上下文。如下所示：</p>
<ul>
<li>recommended。是否是推荐配置。</li>
<li>enabled。是否允许</li>
<li>description。规则描述</li>
<li>message。错误信息</li>
<li>documentationUrl。文档地址。</li>
<li>severity。严重程度，`error`, `warn`, `info`, or `hint`。</li>
<li>formats。格式化标准，如 OpenAPI 2.0、OpenAPI 3.0 等。</li>
<li>resolved。是否已解决。</li>
<li>given。类似于 CSS 中的选择器，使用类似于 XPath 的 JsonPath，<a href="https://goessner.net/articles/JsonPath/index.html">JSONPath</a></li>
<li>then。
<ul>
<li>field，字段</li>
<li>function，函数，模式</li>
<li>functionOptions</li>
</ul>
</li>
</ul>
<p>此外，它还有一个简单的类型系统，以及对应的表达式判断。如下：</p>
<ul>
<li>CASES。flat、camel、pascal、kebab、cobol、snake、macro</li>
<li>长度：最大值、最小值。</li>
<li>数字</li>
<li>Boolean 判断。</li>
<li>类型系统。枚举</li>
</ul>
<p>总的来说，Spectral 在实现上比较灵活有趣。</p>
<h4 id="sqlfluff"><a class="header" href="#sqlfluff">SQLFluff</a></h4>
<p>与 Ktlint 和 Spectral 这种基于已有的数据模型的应用来说，SQLFluff 显得更有挑战性 —— 它是基于多种不同的数据库方言来构建规则的。SQLFluff
是直接基于源码来进行分析的，将不同的数据库方言转换为基本元素（分词）。随后，基于分词的类型 + 规则
，来对它们进行处理。简单来说，就是更抽象的分词上下文，构建对应的规则上下文。如下是</p>
<ul>
<li>segement。位于其核心的是 BaseSegment，它定义了 Lexing、Parsing 和 Linting
三个基本的元素，产生诸如：<code>groupby_clause</code>、<code>orderby_clause</code> 、<code>select_clause</code> 等分词。</li>
<li>parent_stack。</li>
<li>siblings_pre。</li>
<li>siblings_post。</li>
<li>raw_stack。</li>
<li>memory。</li>
<li>dialect。作为语法运行时解析的基础。</li>
<li>path。路径。</li>
<li>templated_file。模板文件。</li>
</ul>
<p>示例：</p>
<pre><code class="language-json">{
  &quot;file&quot;: {
    &quot;statement&quot;: {
      &quot;select_statement&quot;: {
        &quot;select_clause&quot;: {
          &quot;keyword&quot;: &quot;SELECT&quot;,
          &quot;whitespace&quot;: &quot; &quot;,
          &quot;select_clause_element&quot;: {
            &quot;column_reference&quot;: {
              &quot;identifier&quot;: &quot;foo&quot;
            }
          }
        },
        &quot;whitespace&quot;: &quot; &quot;,
        &quot;from_clause&quot;: {
          &quot;keyword&quot;: &quot;FROM&quot;,
          &quot;whitespace&quot;: &quot; &quot;,
          &quot;from_expression&quot;: {
            &quot;from_expression_element&quot;: {
              &quot;table_expression&quot;: {
                &quot;table_reference&quot;: {
                  &quot;identifier&quot;: &quot;bar&quot;
                }
              }
            }
          }
        }
      }
    },
    &quot;statement_terminator&quot;: &quot;;&quot;,
    &quot;newline&quot;: &quot;\n&quot;
  }
}
</code></pre>
<p>随后的规则，便是在对这些规则进行 <code>eval</code>，如下示例：</p>
<pre><code class="language-python">class Rule_L021(BaseRule):
    def _eval(self, context: RuleContext) -&gt; Optional[LintResult]:
        &quot;&quot;&quot;Ambiguous use of DISTINCT in select statement with GROUP BY.&quot;&quot;&quot;
        segment = context.functional.segment
        if (
                segment.all(sp.is_type(&quot;select_statement&quot;))
                # Do we have a group by clause
                and segment.children(sp.is_type(&quot;groupby_clause&quot;))
        ):
            # Do we have the &quot;DISTINCT&quot; keyword in the select clause
            distinct = (
                segment.children(sp.is_type(&quot;select_clause&quot;))
                .children(sp.is_type(&quot;select_clause_modifier&quot;))
                .children(sp.is_type(&quot;keyword&quot;))
                .select(sp.is_name(&quot;distinct&quot;))
            )
            if distinct:
                return LintResult(anchor=distinct[0])
        return None
</code></pre>
<p>在这里所有的规则判断都是基于这种抽象的语法树。从某种意义上来说，构建了一个统一的抽象。本来想进一步分析，但是发现各种 SQL
dialect 里是各种正则表达式，我就选择了临时性撤退。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../category/category-ordered.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="../patterns/gate-guard.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../category/category-ordered.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="../patterns/gate-guard.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script>
            window.playground_copyable = true;
        </script>
        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>
        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
