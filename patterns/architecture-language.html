<!DOCTYPE HTML>
<html lang="zh-cn" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>架构语言 - 架构治理模式</title>
        <!-- Custom HTML head -->
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../index.html">架构治理总览</a></li><li class="chapter-item expanded affix "><li class="part-title">架构治理基础</li><li class="chapter-item expanded "><a href="../basic/architecture-modeling.html"><strong aria-hidden="true">1.</strong> 架构建模</a></li><li class="chapter-item expanded "><a href="../basic/architecture-basic.html"><strong aria-hidden="true">2.</strong> 架构治理基础</a></li><li class="chapter-item expanded "><a href="../basic/architecture-patterns.html"><strong aria-hidden="true">3.</strong> 模式的模式</a></li><li class="chapter-item expanded "><a href="../basic/elemental-pattern.html"><strong aria-hidden="true">4.</strong> 元素化模式</a></li><li class="chapter-item expanded affix "><li class="part-title">数字化治理模式</li><li class="chapter-item expanded "><a href="../category/category-characteristic.html"><strong aria-hidden="true">5.</strong> 特征集合</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../category/category-characteristic-measure.html"><strong aria-hidden="true">5.1.</strong> 特征度量</a></li><li class="chapter-item expanded "><a href="../patterns/characteristics-repository.html"><strong aria-hidden="true">5.2.</strong> 架构特征仓库</a></li><li class="chapter-item expanded "><a href="../patterns/fitness-function.html"><strong aria-hidden="true">5.3.</strong> 架构适应度函数</a></li><li class="chapter-item expanded "><a href="../patterns/architecture-twin.html"><strong aria-hidden="true">5.4.</strong> 架构孪生</a></li></ol></li><li class="chapter-item expanded "><a href="../category/category-analysis.html"><strong aria-hidden="true">6.</strong> 分析</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../patterns/focus-driven.html"><strong aria-hidden="true">6.1.</strong> 关注点驱动</a></li><li class="chapter-item expanded "><a href="../patterns/analysis-lifecycle.html"><strong aria-hidden="true">6.2.</strong> 分解生命周期</a></li><li class="chapter-item expanded "><a href="../patterns/language-metamodel.html"><strong aria-hidden="true">6.3.</strong> 语言元模型</a></li><li class="chapter-item expanded "><a href="../patterns/dynamic-tracing.html"><strong aria-hidden="true">6.4.</strong> 动静态追踪</a></li></ol></li><li class="chapter-item expanded "><a href="../category/category-viz.html"><strong aria-hidden="true">7.</strong> 可视化</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../patterns/city-metaphor.html"><strong aria-hidden="true">7.1.</strong> 城市隐喻</a></li><li class="chapter-item expanded "><a href="../patterns/graph-network.html"><strong aria-hidden="true">7.2.</strong> 图网络</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../patterns/graph-dependency.html"><strong aria-hidden="true">7.2.1.</strong> 依赖图</a></li></ol></li><li class="chapter-item expanded "><a href="../patterns/interactive-analysis.html"><strong aria-hidden="true">7.3.</strong> 交互式分析</a></li></ol></li><li class="chapter-item expanded "><a href="../category/category-ordered.html"><strong aria-hidden="true">8.</strong> 有序</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../patterns/linter-limit-rule.html"><strong aria-hidden="true">8.1.</strong> 规则限定</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../patterns/gate-guard.html"><strong aria-hidden="true">8.1.1.</strong> 门禁</a></li></ol></li><li class="chapter-item expanded "><a href="../patterns/fact-based-modeling.html"><strong aria-hidden="true">8.2.</strong> 表征化建模过程</a></li><li class="chapter-item expanded "><a href="../patterns/lightweight-documentation.html"><strong aria-hidden="true">8.3.</strong> 轻量级文档</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../patterns/architecture-decision-record.html"><strong aria-hidden="true">8.3.1.</strong> 架构决策记录</a></li><li class="chapter-item expanded "><a href="../patterns/all-in-one-page.html"><strong aria-hidden="true">8.3.2.</strong> 架构一页纸</a></li></ol></li><li class="chapter-item expanded "><a href="../patterns/collaborative-workshop.html"><strong aria-hidden="true">8.4.</strong> 协同设计工作坊</a></li><li class="chapter-item expanded "><a href="../patterns/automated-monitoring.html"><strong aria-hidden="true">8.5.</strong> 自动化监测</a></li><li class="chapter-item expanded "><a href="../patterns/scaffolding.html"><strong aria-hidden="true">8.6.</strong> 内建模式的脚手架</a></li></ol></li><li class="chapter-item expanded "><a href="../category/category-language.html"><strong aria-hidden="true">9.</strong> 领域抽象</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../patterns/architecture-as-code.html"><strong aria-hidden="true">9.1.</strong> 架构即代码</a></li><li class="chapter-item expanded "><a href="../patterns/architecture-language.html" class="active"><strong aria-hidden="true">9.2.</strong> 架构语言</a></li><li class="chapter-item expanded "><a href="../patterns/architecture-workbench.html"><strong aria-hidden="true">9.3.</strong> 架构工作台</a></li></ol></li><li class="chapter-item expanded "><a href="../category/category-categorization.html"><strong aria-hidden="true">10.</strong> 范畴化</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../patterns/hierarchical-decomposition.html"><strong aria-hidden="true">10.1.</strong> 层次化分解</a></li><li class="chapter-item expanded "><a href="../patterns/layered-control.html"><strong aria-hidden="true">10.2.</strong> 层级层次控制</a></li><li class="chapter-item expanded "><a href="../patterns/access-control.html"><strong aria-hidden="true">10.3.</strong> 访问控制</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../patterns/limited-core-domain.html"><strong aria-hidden="true">10.3.1.</strong> 有限核心域</a></li></ol></li></ol></li><li class="chapter-item expanded "><li class="part-title">流程与能力治理模式</li><li class="chapter-item expanded "><div><strong aria-hidden="true">11.</strong> 流程</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../process/trend-lead-vision.html"><strong aria-hidden="true">11.1.</strong> X 技术描绘趋势</a></li><li class="chapter-item expanded "><a href="../process/incremental-guidance.html"><strong aria-hidden="true">11.2.</strong> 增量引导</a></li><li class="chapter-item expanded "><a href="../process/context-over-control.html"><strong aria-hidden="true">11.3.</strong> 上下文优于控制</a></li><li class="chapter-item expanded "><a href="../process/decision-framework.html"><strong aria-hidden="true">11.4.</strong> 决策制定框架</a></li><li class="chapter-item expanded "><a href="../process/responsibilities-matrix.html"><strong aria-hidden="true">11.5.</strong> 职责矩阵 (RACI)</a></li><li class="chapter-item expanded "><a href="../process/manage-dependency.html"><strong aria-hidden="true">11.6.</strong> 管理依赖</a></li><li class="chapter-item expanded "><a href="../process/lightweight-architecture-review.html"><strong aria-hidden="true">11.7.</strong> 轻量级架构检视</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">12.</strong> 能力</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../process/capability-assessment.html"><strong aria-hidden="true">12.1.</strong> 能力评估</a></li><li class="chapter-item expanded "><a href="../process/capability-mapping.html"><strong aria-hidden="true">12.2.</strong> 能力映射</a></li><li class="chapter-item expanded "><a href="../process/capability-heat-map.html"><strong aria-hidden="true">12.3.</strong> 能力热图</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">13.</strong> 知识管理</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../process/asset-deposition.html"><strong aria-hidden="true">13.1.</strong> 资产沉淀</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">组织与团队模式</li><li class="chapter-item expanded "><div><strong aria-hidden="true">14.</strong> 团队模式</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../team/team-topology.html"><strong aria-hidden="true">14.1.</strong> 团队拓扑</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">工具化模式</li><li class="chapter-item expanded "><div><strong aria-hidden="true">15.</strong> 工具化模式</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../tools/discovery-development.html"><strong aria-hidden="true">15.1.</strong> 探索-开发模式</a></li><li class="chapter-item expanded "><a href="../tools/self-service-data-analysis.html"><strong aria-hidden="true">15.2.</strong> 自服务数据分析</a></li><li class="chapter-item expanded "><a href="../tools/plugin-system.html"><strong aria-hidden="true">15.3.</strong> 插件化架构</a></li><li class="chapter-item expanded "><a href="../tools/dag-pipeline.html"><strong aria-hidden="true">15.4.</strong> DAG 管道模式</a></li><li class="chapter-item expanded "><a href="../tools/tool-shift-left.html"><strong aria-hidden="true">15.5.</strong> 工具前移</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">反模式</li><li class="chapter-item expanded "><div><strong aria-hidden="true">16.</strong> 流程</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../bad-patterns/pattern-escape.html"><strong aria-hidden="true">16.1.</strong> 模式逃逸</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><li class="part-title">参考资料</li><li class="chapter-item expanded "><a href="../reference/index.html"><strong aria-hidden="true">17.</strong> 参考资料</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">架构治理模式</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/archguard/book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/archguard/book/edit/master/src/patterns/architecture-language.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="架构语言"><a class="header" href="#架构语言">架构语言</a></h1>
<blockquote>
<p>架构描述语言（ADL）是一种计算机语言，用来描述软件或系统架构。这意味着如果是技术性架构，该架构必须被清楚地传达给软件开发者。功能架构下，
该软件架构必须被清楚地传达给利益相关者和企业工程师。一些软件工程团体开发了若干 ADL，如 ACME（CMU开发），AADL（SAE标准化），C2（UCI开发），
Darwin（英国伦敦帝国学院开发）和 Wright（CMU开发） 。</p>
</blockquote>
<p>维基百科：<a href="https://zh.wikipedia.org/wiki/%E6%9E%B6%E6%9E%84%E6%8F%8F%E8%BF%B0%E8%AF%AD%E8%A8%80">架构描述语言</a></p>
<p>ADL原则上的不同之处：</p>
<ul>
<li>需求语言，因为 ADL 植根于解决方案，而需要说明问题。</li>
<li>编程语言，因为 ADL 不能绑定架构抽象到具体解决方案</li>
<li>建模语言，因为 ADL 往往侧重于表现构件而不是整体行为。然而，有重点表现构件的特定域建模语言（DSML）。</li>
</ul>
<h2 id="问题"><a class="header" href="#问题">问题</a></h2>
<h2 id="示例wright"><a class="header" href="#示例wright">示例：Wright</a></h2>
<p>首页：<a href="http://www.cs.cmu.edu/afs/cs/project/able/www/wright/index.html">http://www.cs.cmu.edu/afs/cs/project/able/www/wright/index.html</a></p>
<p>Wright 通过为体系结构描述提供正式基础来解决这个问题。作为一种体系结构描述语言，Wright 可用于为体系结构规范提供精确、抽象的含义，并分析单个软件系统和系统系列的体系结构。
Wright 还充当了探索架构抽象本身本质的工具。特别是，关于 Wright 的工作集中在显式连接器类型的概念、架构属性自动检查的使用以及架构风格的形式化上。</p>
<p>Wright 示例：</p>
<pre><code>Style SharedData
Connector Bogus
    Role User1 = set -&gt; User1 |~| get -&gt; User1 |~| Tick
    Role User2 = set -&gt; User2 |~| get -&gt; User2 |~| Tick
    
    Glue = User1.set -&gt; Continue [] User2.set -&gt; Continue [] Tick
    where {
        Continue = User1.set -&gt; Continue
            [] User2.set -&gt; Continue
            [] User1.get -&gt; Continue
            [] User2.get -&gt; Continue
            [] Tick
    }

End Style
</code></pre>
<h2 id="架构语言fklang"><a class="header" href="#架构语言fklang">架构语言：Fklang</a></h2>
<p>如《<a href="https://www.phodal.com/blog/step-by-step-domain-specific-language-design/">领域特定语言设计技巧</a>》一文中所描述的过程，在这个上下文之下就是：</p>
<ol>
<li>定义呈现模式。寻找适合于呈现架构的方式，如 UML 图、依赖图、时序图等。</li>
<li>提炼领域特定名词。一系列的架构相关元素，如架构风格：微内核等、架构分层：MVC 等。</li>
<li>设计关联关系与语法。如何以自然的方式来关联这些架构元素，如关键词、解析占位符等。</li>
<li>实现语法解析。除了实现之后，另外一种还要考虑的是：如何提供更灵活的扩展能力？</li>
<li>演进语言的设计。版本迭代</li>
</ol>
<h1 id="fklang-示例"><a class="header" href="#fklang-示例">Fklang 示例</a></h1>
<p>过去的几个月的业余时间里，一直在设计一个名为 Fklang （ <a href="https://github.com/feakin/fklang">https://github.com/feakin/fklang</a> ）的架构 DSL，以 DDD（领域驱动设计）为指导思想构建，除了完成 MVP 原型的编译器与代码生成，还可以使用 Jetbrains IDE 开发（搜索 Feakin）。</p>
<p>首先，架构描述语言或者设计语言并不是一个新的东西，Fklang 也是旧瓶新装。我们只是按自己的理解去实现了一遍，只是在实现的过程中，我们发现：<strong>基于标准化的方法论，可以实现规模化的软件开发</strong>。为此，在开发 Fklang 的过程中，便尝试结合了 “大魔头” 的类型流（<a href="https://zhuanlan.zhihu.com/p/341089716">Typeflow</a>）思想，便也以<strong>软件开发工业化</strong>作为 Fklang 的目标之一。只是呢，对于 Fklang 而言，要实现开发工业化，还需要对于基础设施做一系列抽象（后面详细展开）。这也就是为什么文章的标题是探索。</p>
<p>TL；DR 版本：立即开始你的吐槽之旅途：<a href="https://book.feakin.com/quick-start">https://book.feakin.com/quick-start</a> 。</p>
<h2 id="引子-1fklang-缘由archguard-架构治理前移"><a class="header" href="#引子-1fklang-缘由archguard-架构治理前移">引子 1：Fklang 缘由：ArchGuard 架构治理前移</a></h2>
<p>我们开发 Fklang 的初衷是，为了实践在 <a href="https://github.com/archguard">ArchGuard</a> 中定义的三态模型中的设计态。对应三态如下：</p>
<ul>
<li>设计态：目标架构。通过 DSL（领域特定语言） + 架构工作台来构建 。</li>
<li>开发态：实现架构。关注于：可视化 + 自定义分析  + 架构治理。</li>
<li>运行态：运行架构。结合  APM 工具，构建完整的分析链。</li>
</ul>
<p>在 ArchGuard 中，我们关注于对开发态的治理，而其中的手段之一是：<strong>规范工具化</strong>。规范本身是应该内建的，诸如于我们应该制定好分层架构，诸如于 DDD 分层模式。并将这个分层架构与代码实现相绑定，再结合到开发工具中。诸如于 Fklang 的 <code>layer</code> 分层语法便是基于这个理念设计的：</p>
<pre><code class="language-feakin">layered DDD {
  dependency {
    interface -&gt; application
    application -&gt; domain
    interface -&gt; domain
    application -&gt; infrastructure
    interface -&gt; infrastructure
  }
  
  layer interface {
    package: &quot;com.example.book&quot;;
  }
  ...
}
</code></pre>
<p>在与 IDE 结合的情况下，我们就能在开发的过程中，避免开发人员破坏分层架构。这便是 Fklang 的第一个设计理念：<strong>显性化意图设计</strong>。</p>
<h2 id="引子-2领域驱动设计的标准化方法"><a class="header" href="#引子-2领域驱动设计的标准化方法">引子 2：领域驱动设计的标准化方法</a></h2>
<p>在设计 Fklang 的过程中，我们也探索了一系列的架构描述语言，它们都有自己的标准方法论。与此不同的是，我们觉得采用现行的标准化方法，才能让架构语言更容易落地。考虑到，现在更流行的架构设计方法论是 DDD 模式，在进行 <a href="http://domain-driven-design.org/zh/ddd-design-workshop-guide.html">DDD 建模工作坊</a> 时，采用事件风暴或者其它方法，都是通过协作设计的方式进行的，而最后需要一个规范化的输出。</p>
<p>Fklang 便是承载了规范化输出部分，将图形设计代码化，将与实现代码相结合（如代码生成等）。在设计 Fklang 的 DDD 部分语法，我们参考了 <a href="https://contextmapper.org/docs/context-map/">ContextMapper</a> 部分（主要也是设计不出差异），示例如下所示：</p>
<pre><code class="language-feakin">ContextMap TicketBooking {
    Reservation -&gt; Cinema;
    Reservation -&gt; Movie;
    Reservation -&gt; User;
}

Context Reservation {
  Aggregate Reservation;
}

Context Cinema {
  Aggregate Cinema;
}
</code></pre>
<p>通过 Feakin 在线工具（<a href="https://online.feakin.com/">https://online.feakin.com/</a>），可以将上述的 DSL 显性化出来，用于与架构师和开发人员进行交流。</p>
<p>PS：因为 Fklang 还没有实现完整的类型系统，所以在现在的实现是与 DDD 相绑定。</p>
<h2 id="引子-3实现细节与基础设施抽象"><a class="header" href="#引子-3实现细节与基础设施抽象">引子 3：实现细节与基础设施抽象</a></h2>
<p>五年前，在编写《<a href="http://serverless.phodal.com/">Serverless 应用开发指南</a>》时，我便觉得 Serverless 对于规模型团队来说，并不是一个很好的解决方案。但是呢，它提供了一个非常好的架构思考方式：<strong>对实现细节的抽象化</strong>。所以，再回到 Bob 大叔对于《架构整洁之道》的【第 6 部分：实现细节】：</p>
<ul>
<li>数据库是实现细节</li>
<li>Web 是实现细节</li>
<li>应用框架是实现细节</li>
</ul>
<p>然后呢，然后呢，我们需要一个渐进式的 Darklang（<a href="https://darklang.com/">https://darklang.com/</a>），它与框架、Web、数据库无关。我们在写代码的时候，往往只会配置过一次数据库，剩下的数据库操作可能是在<strong>删表与重建</strong>。也因此，在描述数据库时，我们要配置的应该是 env，配置怎样的数据库，怎么的 http server 等等。Fklang 示例如下：</p>
<pre><code class="language-feakin">env Local {
  datasource {
    driver: postgresql
    host: &quot;localhost&quot;
    port: 5432
    database: &quot;test&quot;
  }

  server {
    port: 9090;
  }
}
</code></pre>
<p>既然，我们在设计阶段已经定义好了 Context、Aggregate、Entity 等等，那么这个时候它是不是就可以作为一个 Web Server 运行起来呢？如下图所示：</p>
<p>这便引发了我们对于软件开发工业化的思考。</p>
<h2 id="软件开发工业化定义下一代架构"><a class="header" href="#软件开发工业化定义下一代架构">软件开发工业化：定义下一代架构</a></h2>
<p>虽然，现在我们并没有在 Fklang 中实现真正的软件开发工业化。但是呢，我想在这里分享一下探索过程中的一些理解：</p>
<blockquote>
<p>软件开发工业化是一种批量式加工的软件模式，充分利用机器的学习能力与人工设计的智慧，以在部分工序上由机器取代人，进而实现软件开发的快速规模化。</p>
</blockquote>
<p>简单来说，对于每个功能而言，开发人员接收到需求之后，只需要编写<strong>对应函数</strong>中的功能，剩下的交由 AI 自行去生成与判断。诸如于，我们要新添加一个创建待办事项的 API，那么就自动生成 Controller、Repository 的代码，开发人员只需要编写 Service 中的那个对应 <code>createTodo</code> 方法即可。至于重构嘛，我觉得也不需要，发现重复代码之后，AI 应该自动帮你重构。</p>
<p>基于这样的考虑，我们觉得实现工业化应该达到三个核心点：</p>
<ul>
<li>设计与实现细节分离。只编写核心业务逻辑，无需关注于所有的输入和输出，如数据库、Web API 等。</li>
<li>全生命周期半智能化。对于每一个环节进行量化，便可以实现架构进行自调节。</li>
<li>模式内建于工具。工业化意味着标准化，也意味着知识的固化到系统中，模式是软件开发的核心知识，应该由工具来继承。</li>
</ul>
<p>而一旦实现了架构治理的前置，我们便不再需要关注于如何治理。</p>
<h3 id="设计与实现细节分离基础设施抽象"><a class="header" href="#设计与实现细节分离基础设施抽象">设计与实现细节分离：基础设施抽象</a></h3>
<p>在这一点上，我们与传统的 “甩手架构师” 是保持一样的考虑，设计与一部分的实现细节是相分离的。只是核心的差异之处在于，我们作为架构师，应该构建出基础设施抽象，并显示化出设计意图，诸如于我们前面强调的《实现细节与基础设施抽象》。</p>
<p>我们可以拿 Serverless 架构或者 Faas（函数即服务）作为一个参照物。在采用 FaaS 架构的模式之下，我们并不关注于基础设施，云厂商或者基础设施部门会提供弹性的架构支持。但是呢，FaaS 粒度过细，过多的进程使得我们无法接受这个成本。所以，在考虑工业化时，我们需要实现：<strong>基于微服务之上的函数即服务（FaaS on Microservices）</strong>。从模式上类似于 OSGI 模型，只是实现机制是不一样的。我们理解的类似 <strong>FaaS on Microservices</strong> 的架构，可以每个聚合（aggregate ）在开发时独立运行，又可以与其他聚合一起工作。</p>
<p>而作为开发人员，他们不需要关注于 Web 接口与数据库接口，只需要编写核心业务逻辑即可，Controller 和 JPA 接口可以由设计生成，以达到框架、数据库与设计无关。简单来说，开发人员只需要编写<strong>处理函数</strong>就足够了，应对于 MVC 的 service 中的一个方法，处理输入并返回输出结果。</p>
<h3 id="全生命周期半智能化量化与架构自调节"><a class="header" href="#全生命周期半智能化量化与架构自调节">全生命周期半智能化：量化与架构自调节</a></h3>
<p>我们坚信软件开发工业化另外一个点在于：<strong>基于代码模型的 AI 代码生成</strong>。</p>
<ul>
<li>设计态。通过在 DSL 中写入基本的设计，来生成代码与空函数，让开发人员选择与填空。</li>
<li>开发态。结合 AI 与现有的代码库能力，来判断逻辑是否正确，并进行调整。</li>
<li>运行态。通过监测 API 的运行情况，来自动调整 DDD 中的聚合、限界上下文。</li>
</ul>
<p>在设计  Fklang 的过程中，我们构建了一个 flow 语法，它是用来生成注释给 AI 看的：</p>
<pre><code class="language-feakin">impl UserCreated {
  endpoint {
    POST &quot;/user/{id}&quot;;
  }

  flow {
    via UserRepository::getUserById receive user: User
    via UserRepository::save(user: User) receive user: User;
    via Kafak send User to &quot;user.create&quot;;
  }
}
</code></pre>
<p>其设计思想来源于，我们日常沟通中的，你这个 API 需要先查询哪个表，再 xxx，最后再 xxx。虽然，设计得还比较粗糙，重点还在于输入和输出，在配置了分层之后，会在对应的 Controller （UserController）中插入对应的代码：</p>
<pre><code class="language-java">@PostMapping(&quot;/user/{id}&quot;)
public User createUser() {
    // 1. get user:User from UserRepository.getUserById with ()
    // 2. get user:User from UserRepository.save with (user:User)
    // 3. send User from Kafak to &quot;user.create&quot;
}
</code></pre>
<p>在引入 GitHub Copilot 之后，便可以自动生成靠谱，还有不靠谱的代码。</p>
<p>除此，既然 AI 训练可以实现由 AI 自行调参，并发方面是不是应该自行有机器来学习和设计？而要实现自调节要做的第一件事就是量化，定义成功，以反馈驱动设计。</p>
<h3 id="模式内建于工具"><a class="header" href="#模式内建于工具">模式内建于工具</a></h3>
<p>工业化与手工作坊的区别在于，手工作坊做出的东西品质差异比较大，好的非常好，差的非常差。而工业化，虽然比不上好的，但是至少品质如一。他们所做的事情便是，将模式化的套路内建于机器的流水线之中。对于软件开发来说，也是相似的：</p>
<ul>
<li>采用诸如于 DDD 的 “标准化” 设计方法。</li>
<li>采用统一的开发语言。</li>
<li>……</li>
</ul>
<p>这其实也是每个公司想去做提效的部分。从工业化的角度来说，这里我们认为：复用、效率与规模化是类似于 CAP 的不可能三角。在设计 <a href="https://github.com/inherd/uncode/">Uncode</a> 我们一直想做的事情是：将软件开发过程代码化，以实现自动化。相似的，对于工业化来说，我们也需要在现有的工具中，实现对于这些成熟模式的集成。</p>
<p>从另外一个角度来说，我觉得现有的 IDE 依旧有很大的改进空间。诸如于，既然大部分开发人员不用 TDD，那么 IDE 在接受了 debug 之后，是不是可以记下参数，自动生成测试？</p>
<h2 id="fklangddd-驱动的架构-dsl"><a class="header" href="#fklangddd-驱动的架构-dsl">Fklang：DDD 驱动的架构 DSL</a></h2>
<p>最后，让我们简单再介绍一下 Fklang，一个由 DDD 思想驱动的架构设计语言。</p>
<h3 id="核心设计理念"><a class="header" href="#核心设计理念">核心设计理念</a></h3>
<p>Fklang 的目标是：通过声明式 DSL 来绑定代码实现与架构设计，保证架构设计与实现的一致性。为此，我们有三个核心设计理念：</p>
<ol>
<li>架构孪生：双态绑定。提供架构设计态与实现态的双向绑定，保证架构设计与实现的一致性。</li>
<li>显性化设计意图。将软件设计的意图化，借助于 DSL 语言的特性，将意图转换化代码。</li>
<li>类型与事件驱动。通过事件驱动的方式，将数据类型与领域事件进行绑定。</li>
</ol>
<p>PS：详细介绍见：<a href="https://book.feakin.com/design-principles">https://book.feakin.com/design-principles</a> （还没写完）</p>
<p>大部分的内容已经在上面的内容里介绍了。回到 Fklang 中，我们面临的第一个挑战是：如何在不影响开发效率的前提下，保证架构设计与实现的一致性？对于一个架构语言来说，要让开发人员采用的一个关键点是：<strong>如何真正地提升开发效率</strong>？所以，这也就是我们依赖在探索的地方。</p>
<h3 id="fklang-的其他效能探索"><a class="header" href="#fklang-的其他效能探索">Fklang 的其他效能探索</a></h3>
<p><strong>基于 DDD 产物的 Mock Server</strong>。既然 Fklang 能作为 DDD 设计结果的承载物，那么考虑到  API 设计也是其中的一部分，自然而然地 Mock Server  也是可以跑起来的 —— 读取 Aggregate、Entity 等生成  API。所以，一个 Mock Server 日志示例：</p>
<pre><code class="language-bash">fkl run --main /Volumes/source/feakin/fklang/docs/samples/impl.fkl --func mock-server
Running at http://localhost:9090 !
Routes: 
http://localhost:9090/api/cinema/cinema
http://localhost:9090/api/cinema/cinema/1
http://localhost:9090/api/cinema/screeningroom
http://localhost:9090/api/cinema/screeningroom/1
http://localhost:9090/api/cinema/seat
http://localhost:9090/api/cinema/seat/1
http://localhost:9090/api/movie/movie
</code></pre>
<p>**基于 API 的契约测试。**相似的，我们也将 API 契约作为测试的一部分，可用于测试 API 的实现是否是正确的，如下所示：</p>
<pre><code class="language-feakin">impl UserUpdated {
  endpoint {
    PUT &quot;/user/{id}&quot;;
    request: UpdateUser;
    response: User;
  }
}
</code></pre>
<p>不过，现在支持最好的是 GET 请求：</p>
<pre><code class="language-bash">[2022-11-20T08:58:39Z INFO  fkl] runOpt: RunOpt { main: &quot;/Volumes/source/feakin/fklang/docs/samples/impl.fkl&quot;, path: None, impl_name: Some(&quot;PackageJsonGet&quot;), env: None, func_name: HttpRequest, custom_func: None }
[2022-11-20T08:58:39Z INFO  fkl::builtin::funcs::http_request] headers: {&quot;user-agent&quot;: &quot;Mozilla/5.0 (Windows; U; Windows NT 5.1) AppleWebKit/533.2.1 (KHTML, like Gecko) Chrome/24.0.811.0 Safari/533.2.1&quot;}
[2022-11-20T08:58:39Z INFO  fkl::builtin::funcs::http_request] Content-Type: text/plain; charset=utf-8
</code></pre>
<p>在未来，它也可以作为自动化测试的核心部分。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../patterns/architecture-as-code.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="../patterns/architecture-workbench.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../patterns/architecture-as-code.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="../patterns/architecture-workbench.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script>
            window.playground_copyable = true;
        </script>
        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>
        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
